{
  "swagger": "2.0",
  "info": {
    "description": "Provisioning and deletion of services (CD fixed)",
    "version": "1.0",
    "title": "Service provisioning (CD fixed)"
  },
  "basePath": "/",
  "tags": [
    {
      "name": "Service Intents",
      "description": "Creation, deletion and retrieval of intended L0 (CD Fixed) services<p/>&nbsp;&nbsp;&nbsp;&nbsp;This non-versioned API is meant for use by an end-user as a pass-through to the latest version.WARNING - backwards compatibility is not guaranteed for non-versioned APIs."
    },
    {
      "name": "Service Intents v1",
      "description": "Creation, deletion and retrieval of intended L0 (CD Fixed) services (version 1)"
    },
    {
      "name": "Service Intents v2",
      "description": "Creation, deletion and retrieval of intended L0 (CD Fixed) services (version 2)"
    }
  ],
  "schemes": ["http", "https"],
  "paths": {
    "/ifd/api/serviceIntents": {
      "get": {
        "tags": ["Service Intents"],
        "summary": "Get all Service Intents",
        "description": "Gets all Service Intents currently stored in the database.<p>Prerequisite: At least one Service Intent must exist.</p>",
        "operationId": "getAllIntents",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "label",
            "in": "query",
            "description": "(Optional) Retrieve service intents with the specified service user label",
            "required": false,
            "type": "string"
          },
          {
            "name": "layerRates",
            "in": "query",
            "description": "(Optional) Retrieve service intents that operate at the given layer rate(s)",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "roadmLineName",
            "in": "query",
            "description": "(Optional) Retrieve service intents that utilize the named ROADM Line",
            "required": false,
            "type": "string"
          },
          {
            "name": "supportingServiceName",
            "in": "query",
            "description": "(Optional) Retrieve all client service intents for the specified supporting (infrastructure) service name",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Intents retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponseArray"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      },
      "post": {
        "tags": ["Service Intents"],
        "summary": "Not Supported - Create Service Intents",
        "description": "This API validates intent attributes, computes a path and schedules intent realization for deployment.<p>Prerequisite: The entered Service Intent is valid.</p>",
        "operationId": "createIntent",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Intent as a JSON Profile wrapper object",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ServiceIntentRequest"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Intent is created, realized and scheduled",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        },
        "deprecated": true
      }
    },
    "/ifd/api/serviceIntents/deleteIntent/{id}": {
      "delete": {
        "tags": ["Service Intents"],
        "summary": "For INTERNAL USE ONLY: Deletes a Service Intent based on its identifier from IFD DB only",
        "description": "This API deletes service Intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "deleteServiceIntent",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "204": {
            "description": "Intent deleted"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/serviceIntents/{id}": {
      "get": {
        "tags": ["Service Intents"],
        "summary": "Get a Service Intent based on its identifier",
        "description": "This API retrieves an Intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "getIntent",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Intent retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      },
      "delete": {
        "tags": ["Service Intents"],
        "summary": "Delete a Service Intent based on its identifier",
        "description": "This API deletes an Intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "deleteIntent",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "204": {
            "description": "Intent deleted"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/serviceIntents/{id}/deploy": {
      "post": {
        "tags": ["Service Intents"],
        "summary": "Not Supported - Deploy a Service Intent based on its identifier",
        "description": "This API deploys a created service intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "deployIntent",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        },
        "deprecated": true
      }
    },
    "/ifd/api/serviceIntents/{id}/forceFailState": {
      "post": {
        "tags": ["Service Intents"],
        "summary": "Force State the Service Intent based on its identifier",
        "description": "This API switches the service intent to FAILED_ACTIVATING/FAILED_DEACTIVATING from ACTIVATING/DEACTIVATING respectively based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "forceState",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/serviceIntents/{id}/realignState": {
      "post": {
        "tags": ["Service Intents"],
        "summary": "Not Supported - Realign Service Intent based on its identifier",
        "description": "This API will realign service intent state to its resource trackers states in case where service intent is in ACTIVATING state but all intent resource trackers are ACTIVATED.Similarly, intent state is in DEACTIVATING state but all intent resource trackers are DEACTIVATED.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "realignState",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        },
        "deprecated": true
      }
    },
    "/ifd/api/serviceIntents/{id}/resourceTrackers": {
      "get": {
        "tags": ["Service Intents"],
        "summary": "Get Service Intent Resource Trackers based on its identifier",
        "description": "This API retrieves all resource trackers based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "getServiceResourceTrackers",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "ServiceIntent ResourceTrackers retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentRoutes"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/serviceIntents/{id}/route": {
      "get": {
        "tags": ["Service Intents"],
        "summary": "Get Service Intent Route based on its identifier",
        "description": "This API retrieves a Route based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "getServiceRoute",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Route retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentRoutes"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "404": {
            "description": "Route id not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/serviceIntents/{id}/undeploy": {
      "post": {
        "tags": ["Service Intents"],
        "summary": "Begins undeployment of a service intent based on its identifier",
        "description": "This API undeploys a service based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "undeployIntent",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "name": "ignoreClientServiceDependencies",
            "in": "query",
            "description": "(Optional. Demo Only - not officially supported) Bypasses service provisioning client service validation if set to true",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "Intent found and undeployment will begin"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "412": {
            "description": "Intent not in correct state",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/serviceIntents/{id}/update": {
      "put": {
        "tags": ["Service Intents"],
        "summary": "Updates a Service Intent based on its identifier",
        "description": "This API modifies an existing service intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "updateIntent",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Intent with the fields to be updated",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ServiceIntentRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Update successful",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "400": {
            "description": "Invalid input"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v1/serviceIntents": {
      "get": {
        "tags": ["Service Intents v1"],
        "summary": "Get all Service Intents",
        "description": "Gets all Service Intents currently stored in the database.<p>Prerequisite: At least one Service Intent must exist.</p>",
        "operationId": "getAllIntents",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "label",
            "in": "query",
            "description": "(Optional) Retrieve service intents with the specified service user label",
            "required": false,
            "type": "string"
          },
          {
            "name": "layerRates",
            "in": "query",
            "description": "(Optional) Retrieve service intents that operate at the given layer rate(s)",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "roadmLineName",
            "in": "query",
            "description": "(Optional) Retrieve service intents that utilize the named ROADM Line",
            "required": false,
            "type": "string"
          },
          {
            "name": "supportingServiceName",
            "in": "query",
            "description": "(Optional) Retrieve all client service intents for the specified supporting (infrastructure) service name",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Intents retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponseArray"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      },
      "post": {
        "tags": ["Service Intents v1"],
        "summary": "Not Supported - Create Service Intents",
        "description": "This API validates intent attributes, computes a path and schedules intent realization for deployment.<p>Prerequisite: The entered Service Intent is valid.</p>",
        "operationId": "createIntent",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Intent as a JSON Profile wrapper object",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ServiceIntentRequest"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Intent is created, realized and scheduled",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        },
        "deprecated": true
      }
    },
    "/ifd/api/v1/serviceIntents/deleteIntent/{id}": {
      "delete": {
        "tags": ["Service Intents v1"],
        "summary": "For INTERNAL USE ONLY: Deletes a Service Intent based on its identifier from IFD DB only",
        "description": "This API deletes service Intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "deleteServiceIntent",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "204": {
            "description": "Intent deleted"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v1/serviceIntents/getFeasibleRoute": {
      "post": {
        "tags": ["Service Intents v1"],
        "summary": "Get Feasible Route",
        "description": "This API returns a feasible route based on provided input parameters, but does not persist the route.<p>Prerequisite: The entered input is valid (including checks such as that the label must be unique).</p>",
        "operationId": "getFeasibleRoute",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Inputs as a JSON Profile wrapper object",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ServiceIntentRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Feasibility check has completed without error",
            "schema": {
              "$ref": "#/definitions/ServiceIntentRoute"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v1/serviceIntents/{id}": {
      "get": {
        "tags": ["Service Intents v1"],
        "summary": "Get a Service Intent based on its identifier",
        "description": "This API retrieves an Intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "getIntent",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Intent retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      },
      "delete": {
        "tags": ["Service Intents v1"],
        "summary": "Delete a Service Intent based on its identifier",
        "description": "This API deletes an Intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "deleteIntent",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "204": {
            "description": "Intent deleted"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v1/serviceIntents/{id}/deploy": {
      "post": {
        "tags": ["Service Intents v1"],
        "summary": "Not Supported - Deploy a Service Intent based on its identifier",
        "description": "This API deploys a created service intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "deployIntent",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        },
        "deprecated": true
      }
    },
    "/ifd/api/v1/serviceIntents/{id}/forceFailState": {
      "post": {
        "tags": ["Service Intents v1"],
        "summary": "Force State the Service Intent based on its identifier",
        "description": "This API switches the service intent to FAILED_ACTIVATING/FAILED_DEACTIVATING from ACTIVATING/DEACTIVATING respectively based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "forceState",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v1/serviceIntents/{id}/realignState": {
      "post": {
        "tags": ["Service Intents v1"],
        "summary": "Not Supported - Realign Service Intent State based on its identifier",
        "description": "This API will realign service intent state to its resource trackers states in case where service intent is in ACTIVATING state but all intent resource trackers are ACTIVATED.Similarly, intent state is in DEACTIVATING state but all intent resource trackers are DEACTIVATED.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "realignState",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        },
        "deprecated": true
      }
    },
    "/ifd/api/v1/serviceIntents/{id}/resourceTrackers": {
      "get": {
        "tags": ["Service Intents v1"],
        "summary": "Get Service Intent Resource Trackers based on its identifier",
        "description": "This API retrieves all resource trackers based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "getServiceResourceTrackers",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "ServiceIntent ResourceTrackers retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentRoute"
            }
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v1/serviceIntents/{id}/route": {
      "get": {
        "tags": ["Service Intents v1"],
        "summary": "Get Service Intent Route based on its identifier",
        "description": "This API retrieves a Route based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "getServiceRoute",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Route retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentRoute"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "404": {
            "description": "Route id not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        },
        "deprecated": true
      }
    },
    "/ifd/api/v1/serviceIntents/{id}/undeploy": {
      "post": {
        "tags": ["Service Intents v1"],
        "summary": "Begins undeployment of a service intent based on its identifier",
        "description": "This API undeploys a service based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "undeployIntent",
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "name": "ignoreClientServiceDependencies",
            "in": "query",
            "description": "(Optional. Demo Only - not officially supported) Bypasses service provisioning client service validation if set to true",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "Intent found and undeployment will begin"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "412": {
            "description": "Intent not in correct state",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v1/serviceIntents/{id}/update": {
      "put": {
        "tags": ["Service Intents v1"],
        "summary": "Updates a Service Intent based on its identifier",
        "description": "This API modifies an existing service intent based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "updateIntent",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Intent with the fields to be updated",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ServiceIntentRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Update successful",
            "schema": {
              "$ref": "#/definitions/ServiceIntentResponse"
            }
          },
          "400": {
            "description": "Invalid input"
          },
          "404": {
            "description": "Intent not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    },
    "/ifd/api/v2/serviceIntents/{id}/route": {
      "get": {
        "tags": ["Service Intents v2"],
        "summary": "Get Service Intent Route based on its identifier",
        "description": "This API retrieves a Route based on ID.<p>Prerequisite: A Service Intent must exist with the given ID.</p>",
        "operationId": "getServiceRoute",
        "consumes": ["application/json"],
        "produces": ["application/json"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the service intent",
            "required": true,
            "type": "string",
            "format": "uuid"
          }
        ],
        "responses": {
          "200": {
            "description": "Route retrieved",
            "schema": {
              "$ref": "#/definitions/ServiceIntentRoutes"
            }
          },
          "400": {
            "description": "Invalid input",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "404": {
            "description": "Route id not found",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          },
          "500": {
            "description": "Internal system error",
            "schema": {
              "$ref": "#/definitions/Errors"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "AccessPoint": {
      "type": "object",
      "properties": {
        "adaptsToLayerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "adaptsToLayerRateQualifier": {
          "type": "string",
          "description": "Provides a means to provide additional qualification attributes for a Layer Rate. For example, for beyond 100G rates OTUCn and ODUCn, the value of n, where n is a multiple of 100. For example, for beyond 100G rates with sub rate potential (i.e. OTUCn-M), this includes the n-M options where n is the number of OxUC overhead instances and M is the number of 5G tributary slots. For example, OTUC4-60 implies 4 instances of OxUC overhead, and 300G capacity (5G x 60).",
          "enum": [
            "ODUC1",
            "ODUC2",
            "ODUC2_25",
            "ODUC2_30",
            "ODUC3",
            "ODUC4",
            "ODUC4_60",
            "ODUC4_70",
            "ODUC5",
            "ODUC6",
            "ODUC7",
            "ODUC8",
            "OTUC1",
            "OTUC2",
            "OTUC2_25",
            "OTUC2_30",
            "OTUC3",
            "OTUC3_50",
            "OTUC4",
            "OTUC4_60",
            "OTUC5",
            "OTUC6",
            "OTUC7",
            "OTUC8",
            "OC3",
            "OC12",
            "OC48",
            "OC192",
            "OC768",
            "STM1",
            "STM4",
            "STM16",
            "STM64",
            "STM256",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "_1GE",
            "_10GE",
            "_40GE",
            "_100GE",
            "_400GE",
            "_2G5",
            "_1G25",
            "_10G",
            "_40G",
            "_100G",
            "_150G",
            "_200G",
            "_250G",
            "_300G",
            "_350G",
            "_400G",
            "_500G",
            "_600G",
            "_700G",
            "_800G",
            "ETHFLEX",
            "FICON1G",
            "FICONEXPRESS2G",
            "FICON4G",
            "FICON8G",
            "FICON16G",
            "FC100",
            "FC200",
            "FC400",
            "FC800",
            "FC1200",
            "FC1600",
            "FC3200",
            "UNKNOWN"
          ]
        },
        "cardinality": {
          "type": "string",
          "description": "Number of possible potential TPEs. Can be a numeric (eg '1', '96', '1000', ...) or can be categorical (eg 'indirect')."
        },
        "clientTpeRulesInOwnLayer": {
          "type": "array",
          "description": "Directions of how to instantiate client TPE(s) for this access point, including indirect (client over client) client TPE instantiation.",
          "items": {
            "$ref": "#/definitions/ConnectionRule"
          }
        },
        "lifeCycleRules": {
          "description": "Indicates the life cycle rules for an entity.",
          "$ref": "#/definitions/LifeCycleRule"
        },
        "regenIdPackage": {
          "description": "This package stores regen related information.",
          "$ref": "#/definitions/RegenIdPackage"
        },
        "cascadedDtlTpePackage": {
          "description": "This package stores cascaded dtl tpe information.",
          "$ref": "#/definitions/CascadedDtlTpePackage"
        },
        "mirroringBandwidthRules": {
          "type": "string",
          "description": "The mirroringBandwithRules for capacity calculation"
        },
        "mirroringNamingRules": {
          "type": "string",
          "description": "The mirroringNamingRules for capacity calculation"
        },
        "totalCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "usedCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "potentialGrowthCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "plannedCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "namingRules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NamingRules"
          }
        },
        "stitchingConstraint": {
          "type": "string",
          "description": "stitchingConstraint values",
          "enum": ["otnRegen"]
        }
      }
    },
    "AdaptationPool": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the AdaptationPool. Unique in the scope of this TPE."
        },
        "logicalRule": {
          "type": "string",
          "description": "Restrict the number of active poolAdapters could be xOR or OR - default is OR",
          "enum": ["xOR", "OR"]
        },
        "poolAdapters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Adapter"
          }
        },
        "memberAdaptationPools": {
          "type": "array",
          "description": "Reference(s) to 0 or more member AdaptationPool-s. Allows for nesting of AdaptationPools.",
          "items": {
            "type": "string"
          }
        },
        "namingRules": {
          "description": "Various miscellaneous attributes that do not necessarily belong in the parent resource. Attributes are populated dynamically and therefore cannot be documented here.",
          "$ref": "#/definitions/AdditionalAttributes"
        }
      }
    },
    "Adapter": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the Adapter. Unique in the scope of this TPE."
        },
        "adaptsToLayerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "adaptsToLayerRateQualifier": {
          "type": "string",
          "description": "Provides a means to provide additional qualification attributes for a Layer Rate. For example, for beyond 100G rates OTUCn and ODUCn, the value of n, where n is a multiple of 100. For example, for beyond 100G rates with sub rate potential (i.e. OTUCn-M), this includes the n-M options where n is the number of OxUC overhead instances and M is the number of 5G tributary slots. For example, OTUC4-60 implies 4 instances of OxUC overhead, and 300G capacity (5G x 60).",
          "enum": [
            "ODUC1",
            "ODUC2",
            "ODUC2_25",
            "ODUC2_30",
            "ODUC3",
            "ODUC4",
            "ODUC4_60",
            "ODUC4_70",
            "ODUC5",
            "ODUC6",
            "ODUC7",
            "ODUC8",
            "OTUC1",
            "OTUC2",
            "OTUC2_25",
            "OTUC2_30",
            "OTUC3",
            "OTUC3_50",
            "OTUC4",
            "OTUC4_60",
            "OTUC5",
            "OTUC6",
            "OTUC7",
            "OTUC8",
            "OC3",
            "OC12",
            "OC48",
            "OC192",
            "OC768",
            "STM1",
            "STM4",
            "STM16",
            "STM64",
            "STM256",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "_1GE",
            "_10GE",
            "_40GE",
            "_100GE",
            "_400GE",
            "_2G5",
            "_1G25",
            "_10G",
            "_40G",
            "_100G",
            "_150G",
            "_200G",
            "_250G",
            "_300G",
            "_350G",
            "_400G",
            "_500G",
            "_600G",
            "_700G",
            "_800G",
            "ETHFLEX",
            "FICON1G",
            "FICONEXPRESS2G",
            "FICON4G",
            "FICON8G",
            "FICON16G",
            "FC100",
            "FC200",
            "FC400",
            "FC800",
            "FC1200",
            "FC1600",
            "FC3200",
            "UNKNOWN"
          ]
        },
        "poolAdapterType": {
          "type": "string",
          "description": "The type for the adapter."
        },
        "connectionRulesInAdaptationLayer": {
          "type": "array",
          "description": "Directions of how to instantiate client TPE(s) for this adapter, including indirect (client over client) client TPE instantiation.",
          "items": {
            "$ref": "#/definitions/ConnectionRule"
          }
        },
        "cardinality": {
          "type": "string",
          "description": "Number of possible potential TPEs. Can be a numeric (eg '1', '96', '1000', ...) or can be categorical (eg 'indirect')."
        },
        "continuousAdapterRulesPackage": {
          "description": "This package stores various rules to be considered when instantiating a new TPE utilizing continuous b/w.",
          "$ref": "#/definitions/ContinuousAdapterRulesPackage"
        },
        "mappingInteractionRules": {
          "type": "array",
          "description": "The specification of the interaction between the support for different client layer protocols signals.",
          "items": {
            "$ref": "#/definitions/MappingInteractionRule"
          }
        },
        "potentialAdapterCapacities": {
          "type": "array",
          "description": "Total potential capacity of this Adapter.",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "lifeCycleRules": {
          "description": "Indicates the life cycle rules for an entity.",
          "$ref": "#/definitions/LifeCycleRule"
        },
        "photonicSpectrumPackage": {
          "description": "This package stores photonic spectrum information.",
          "$ref": "#/definitions/PhotonicSpectrumPackage"
        },
        "nameToCapacityMappingRules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NameToCapacityMappingRules"
          }
        },
        "eFreTerminationState": {
          "type": "string",
          "description": "Values to handle TPEs that have multiple poolAdapters, especially multiple poolAdapters adapting to the same layer rate",
          "enum": ["hapFre_terminated", "hapFre_not_terminated"]
        },
        "additionalAttributes": {
          "description": "Various miscellaneous attributes that do not necessarily belong in the parent resource. Attributes are populated dynamically and therefore cannot be documented here.",
          "$ref": "#/definitions/AdditionalAttributes"
        },
        "mirroringBandwidthRules": {
          "type": "string",
          "description": "The mirroringBandwithRules for capacity calculation"
        },
        "mirroringNamingRules": {
          "type": "string",
          "description": "The mirroringNamingRules for capacity calculation"
        },
        "totalCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "usedCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "potentialGrowthCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "plannedCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "namingRules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NamingRules"
          }
        },
        "stitchingConstraint": {
          "type": "string",
          "description": "stitchingConstraint values",
          "enum": ["otnRegen"]
        }
      }
    },
    "AdditionalAttributes": {
      "type": "object"
    },
    "AdjacencyPackage": {
      "type": "object",
      "properties": {
        "adjacencyType": {
          "type": "string",
          "description": "This field delimits the adjacency type between two network elements (Ex: LIM, LINE, etc...)."
        },
        "localTag": {
          "type": "string",
          "description": "The actual tag of the originating network element."
        },
        "localTagFormat": {
          "type": "string",
          "description": "The format of the local adjacency tag."
        },
        "provisionedRemoteTag": {
          "type": "string",
          "description": "The provisioned remote tag is the expected destination defined by the user that adheres to the remoteTagFormat."
        },
        "provisionedRemoteTagFormat": {
          "type": "string",
          "description": "The format of the remote provisioning adjacency tag."
        },
        "remoteTag": {
          "type": "string",
          "description": "The actual remote tag as discovered by the network element."
        },
        "remoteTagFormat": {
          "type": "string",
          "description": "The format of the remote adjacency tag."
        },
        "topologySourceTag": {
          "type": "string",
          "description": "The tag representing the topological state. This could be 'DISCOVERED', for example."
        },
        "adjacencyMechanism": {
          "type": "string",
          "description": "The attribute defining the adjacency mechanism used."
        },
        "linkAttributes": {
          "description": "This package stores information of Link.",
          "$ref": "#/definitions/LinkAttributes"
        }
      }
    },
    "AfiSafiNextHopSelf": {
      "type": "object",
      "properties": {
        "configured": {
          "type": "boolean",
          "description": "true/false depending on if nbr is added as route reflector client for afi and safi",
          "default": false
        },
        "excludeReflectedRoutes": {
          "type": "boolean",
          "description": "true/false depending on if nbr is added as route reflector client for afi and safi",
          "default": false
        }
      }
    },
    "AfiSafiOrf": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Outbound Route Filtering type"
        },
        "direction": {
          "type": "string",
          "description": "Outbound Route Filtering direction",
          "enum": ["rx", "tx", "both"]
        }
      }
    },
    "AfiSafiPrefixList": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name to filter BGP advertisements."
        },
        "direction": {
          "type": "string",
          "description": "Direction to filter BGP advertisements.",
          "enum": ["in", "out"]
        }
      }
    },
    "BandwidthThreshold": {
      "type": "object",
      "properties": {
        "ODU0": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (here unit of ODU0) advertised for a link."
        },
        "ODU1": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (here unit of ODU1) advertised for a link."
        },
        "ODU2": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (here unit of ODU2) advertised for a link."
        },
        "ODU2E": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (here unit of ODU2E) advertised for a link."
        },
        "ODU3": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (here unit of ODU3) advertised for a link."
        },
        "ODU4": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (here unit of ODU4) advertised for a link."
        },
        "ODUFLEXRSZ": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (in Bps) for Resizable ODU Flex advertised for a link."
        },
        "ODUFLEXNRSZ": {
          "type": "string",
          "description": "The Bandwidth Threshold shows the maximum number of bandwidth units (in Bps) for Non-Resizable ODU Flex advertised for a link."
        }
      }
    },
    "Bfd": {
      "type": "object",
      "properties": {
        "bfdType": {
          "type": "string",
          "description": "Type of BFD - ipBFD, mplsBFD or bgpBFD",
          "enum": ["ipBFD", "mplsBFD", "bgpBFD"]
        },
        "configured": {
          "type": "boolean",
          "description": "True when BFD is enabled on this endpoint",
          "default": false
        },
        "profileName": {
          "type": "string",
          "description": "The profile name associated with this set of BFD attributes"
        },
        "adminState": {
          "type": "string",
          "description": "The administrative state of BFD for this endpoint",
          "enum": ["up", "down"]
        },
        "operationalState": {
          "type": "string",
          "description": "The operational state of BFD for this endpoint",
          "enum": ["up", "down"]
        },
        "role": {
          "type": "string",
          "description": "The role of BFD for this endpoint",
          "enum": ["passive", "active", "any"]
        },
        "transmitInterval": {
          "type": "string",
          "description": "The interval between transmitting BFD messages"
        },
        "receiveInterval": {
          "type": "string",
          "description": "The interval between receiving BFD messages"
        },
        "ipEncapsulation": {
          "type": "boolean",
          "description": "To report IP settings on the interface",
          "default": false
        },
        "pathType": {
          "type": "string",
          "description": "Single-hop BFD or Multi-hop BFD",
          "enum": ["ipsh", "ipmh"]
        },
        "srcAddress": {
          "type": "string",
          "description": "Local IP address"
        },
        "destAddress": {
          "type": "string",
          "description": "IP address of the peer"
        },
        "localMultiplier": {
          "type": "integer",
          "format": "int32",
          "description": "The negotiated transmit interval, multiplied by this value, provides the Detection Time for the receiving system"
        },
        "desiredMinTxInterval": {
          "type": "string",
          "description": "Rate at which BFD Control packets are transmitted to the remote system "
        },
        "requiredMinRxInterval": {
          "type": "string",
          "description": "Rate at which BFD Control packets arrive from the remote system"
        },
        "sourcePort": {
          "type": "integer",
          "format": "int32",
          "description": "Source UDP port valid only when IP encapsulation is used"
        },
        "destPort": {
          "type": "integer",
          "format": "int32",
          "description": "Destination UDP port valid only when IP encapsulation is used"
        },
        "diagnostic": {
          "type": "string",
          "description": "A diagnostic code specifying the local system's reason for the last change in session state"
        },
        "mhop": {
          "type": "boolean",
          "description": "True when multihop IP BFD is enabled for BGP on this endpoint",
          "default": false
        }
      }
    },
    "BgpAfiSafi": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Supported afi-safi names.",
          "enum": ["IPV4_UNICAST", "IPV4_LABELED_UNICAST"]
        },
        "activated": {
          "type": "boolean",
          "description": "true if activated otherwise false",
          "default": false
        },
        "grCapability": {
          "type": "string",
          "description": "GR capability",
          "enum": ["enabled", "disabled"]
        },
        "prefixList": {
          "description": "This stores BGP Afi Safi Prefix List related information.",
          "$ref": "#/definitions/AfiSafiPrefixList"
        },
        "orf": {
          "description": "This stores BGP Afi Safi Orf related information.",
          "$ref": "#/definitions/AfiSafiOrf"
        },
        "rrEnabled": {
          "type": "boolean",
          "description": "true/false depending on if nbr is added as route reflector client for afi and safi",
          "default": false
        },
        "nextHopSelf": {
          "description": "This stores BGP Afi Safi NextHopSelf related information.",
          "$ref": "#/definitions/AfiSafiNextHopSelf"
        }
      }
    },
    "BgpBfd": {
      "type": "object",
      "properties": {
        "configured": {
          "type": "boolean",
          "description": "True when BFD is enabled on this endpoint",
          "default": false
        },
        "profileName": {
          "type": "string",
          "description": "The profile name associated with this set of BFD attributes"
        },
        "adminState": {
          "type": "string",
          "description": "The administrative state of BFD for this endpoint",
          "enum": ["up", "down"]
        },
        "operationalState": {
          "type": "string",
          "description": "The operational state of BFD for this endpoint",
          "enum": ["up", "down"]
        },
        "role": {
          "type": "string",
          "description": "The role of BFD for this endpoint",
          "enum": ["passive", "active", "any"]
        },
        "transmitInterval": {
          "type": "string",
          "description": "The interval between transmitting BFD messages"
        },
        "receiveInterval": {
          "type": "string",
          "description": "The interval between receiving BFD messages"
        },
        "mhop": {
          "type": "boolean",
          "description": "True when BFD is enabled on this endpoint",
          "default": false
        }
      }
    },
    "BgpMsgs": {
      "type": "object",
      "properties": {
        "peerInUpdates": {
          "type": "string",
          "description": "Number of peer in updates"
        },
        "peerOutUpdates": {
          "type": "string",
          "description": "Number of peer out updates"
        },
        "peerInTotalMessages": {
          "type": "string",
          "description": "Total Number of peer messages"
        },
        "peerOutTotalMessages": {
          "type": "string",
          "description": "Total number of peer out messages"
        },
        "peerInUpdateElapsedTime": {
          "type": "string",
          "description": "Peer updated elapsed time in seconds"
        },
        "lastError": {
          "description": "This stores BGP Message Last Error related information.",
          "$ref": "#/definitions/MsgsLastError"
        }
      }
    },
    "BgpPackage": {
      "type": "object",
      "properties": {
        "peerType": {
          "type": "string",
          "description": "internal/external depending on peerAs number is same as local or different.",
          "enum": ["internal", "external"]
        },
        "peerAs": {
          "type": "integer",
          "format": "int64",
          "description": "Autonomous System number configured for the peer."
        },
        "peerBgpIdentifier": {
          "type": "string",
          "description": "BGP identifier of the peer. Learned only in OPEN CONFIRM and ESTABLISHED states."
        },
        "peerState": {
          "type": "string",
          "description": "BGP states",
          "enum": [
            "idle",
            "connect",
            "active",
            "opensent",
            "openconfirm",
            "established"
          ]
        },
        "peerNegotiatedBGPVersion": {
          "type": "string",
          "description": "Learned only in OPENCONFIRM and ESTABLISHED states."
        },
        "peerFsmEstablishedTransitions": {
          "type": "string",
          "description": "Peer Fsm established transitions."
        },
        "peerFsmEstablishedTime": {
          "type": "string",
          "description": "Peer Fsm established time in seconds."
        },
        "bfd": {
          "description": "Holds BFD attributes for BGP TPE endpoint",
          "$ref": "#/definitions/BgpBfd"
        },
        "transport": {
          "description": "This package stores BGP transport related information.",
          "$ref": "#/definitions/BgpTransport"
        },
        "timers": {
          "description": "This package stores BGP time related information.",
          "$ref": "#/definitions/BgpTimers"
        },
        "rr": {
          "description": "This package stores BGP route reflector related information.",
          "$ref": "#/definitions/BgpRr"
        },
        "msgs": {
          "description": "This package stores BGP message related information.",
          "$ref": "#/definitions/BgpMsgs"
        },
        "afiSafi": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BgpAfiSafi"
          }
        }
      }
    },
    "BgpRr": {
      "type": "object",
      "properties": {
        "peerClusterId": {
          "type": "string",
          "description": "The cluster-id to which peer belongs if it is configured as RR client."
        },
        "peerRole": {
          "type": "string",
          "description": "Role of the peer",
          "enum": ["client", "routeReflector"]
        },
        "role": {
          "type": "string",
          "description": "self role",
          "enum": ["client", "routeReflector"]
        }
      }
    },
    "BgpTimers": {
      "type": "object",
      "properties": {
        "peerConnectRetryInterval": {
          "type": "string",
          "description": "Peer connection retry intervel in seconds."
        },
        "peerNegotiatedHoldTime": {
          "type": "string",
          "description": "Peer negotiation hold time in seconds"
        },
        "peerConfiguredHoldTime": {
          "type": "string",
          "description": "Peer configured hold time in seconds"
        },
        "peerNegotiatedKeepAliveTime": {
          "type": "string",
          "description": "Peer negotiation keep alive time in seconds"
        },
        "peerConfiguredKeepAliveTime": {
          "type": "string",
          "description": "Peer configured keep alive time in seconds"
        },
        "peerMinASOriginationInterval": {
          "type": "string",
          "description": "Peer minimum AS origination intervel in seconds"
        },
        "peerMinRouteAdvertisementInterval": {
          "type": "string",
          "description": "Peer minimum advertised intervel in seconds"
        }
      }
    },
    "BgpTransport": {
      "type": "object",
      "properties": {
        "localIp": {
          "type": "string",
          "description": "If update-source is configured then IP address of the interface. Rely on learned localIp if it is reported. Reported in OPENCONFIRM and ESTABLISHED states."
        },
        "localPort": {
          "type": "string",
          "description": "Local port reported in OPENCONFIRM and ESTABLISHED states."
        },
        "peerIp": {
          "type": "string",
          "description": "Peer Ip configured as part of BGP peer configuration."
        },
        "peerPort": {
          "type": "string",
          "description": "Peer port reported in OPENCONFIRM and ESTABLISHED states."
        }
      }
    },
    "Bw": {
      "type": "object",
      "properties": {
        "unit": {
          "type": "string",
          "description": "The bandwidth unit that applies to all bandwidth attributes in this package. Available values: bps, kbps, mbps, gbps"
        },
        "used": {
          "type": "string",
          "description": "The current used bandwidth by all supported clients"
        },
        "minimum": {
          "type": "string",
          "description": "The minimum bandwidth configured for supported clients"
        },
        "maximum": {
          "type": "string",
          "description": "The maximum bandwidth configured for supported clients"
        },
        "increment": {
          "type": "string",
          "description": "The configured bandwidth increment for auto-sizing of an MPLS tunnel"
        },
        "requested": {
          "type": "string",
          "description": "The requested bandwidth from the supporting layer, e.g. a dynamic tunnel requesting bandwidth from IP interface"
        },
        "operational": {
          "type": "string",
          "description": "The current bandwidth being allocated from the supporting layer"
        },
        "total": {
          "type": "string",
          "description": "The total bandwidth allocated or allowed, e.g. the capacity of an IP interface"
        },
        "bookingFactor": {
          "type": "string",
          "description": "The booking factor of how much the bandwidth can be oversubscribed, e.g. on an IP interface"
        },
        "maxReservable": {
          "type": "string",
          "description": "The maximum reservable bandwidth allowed to be allocated to supported clients and it's calculated as bwBookingFactor x bwTotal"
        },
        "available": {
          "type": "string",
          "description": "The available bandwidth left to be"
        },
        "autoSize": {
          "type": "string",
          "description": "If true, the MPLS tunnel will be auto-sized by the NE",
          "enum": ["enable", "disable"]
        },
        "autoSizingMode": {
          "type": "string",
          "description": "The configured auto-sizing mode",
          "enum": ["none", "cac", "utilization"]
        },
        "autoSizeFailureAction": {
          "type": "string",
          "description": "The action to be taken when auto-sizing fails: raise alarm, or make-before-break",
          "enum": ["none", "alarm", "mbb"]
        },
        "autoSizeIntervalMinutes": {
          "type": "string",
          "description": "The configured interval between auto-sizing attempts"
        },
        "autoSizeLastResizeState": {
          "type": "string",
          "description": "The state of the last auto-sizing attempt",
          "enum": ["success", "failure", "in_progress"]
        },
        "autoSizeLastResizeStartTime": {
          "type": "string",
          "description": "Start time of the last auto resize happened"
        },
        "autoSizeLastResizeEndTime": {
          "type": "string",
          "description": "End time of the last auto resize happened"
        },
        "autoSizeLastResizeReason": {
          "type": "string",
          "description": "Reason of the last auto resize happened"
        },
        "profileName": {
          "type": "string",
          "description": "The name of the bandwidth profile associated with the dynamic tunnel endpoint"
        }
      }
    },
    "Capacity": {
      "type": "object",
      "properties": {
        "layer": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "capacityClass": {
          "type": "string",
          "description": "Discrete – b/w space is treated as a list of discrete values; this is default. Continuous – b/w space is treated as continuous segment, in the range of low/upper.",
          "enum": ["discrete", "continuous"]
        },
        "capacity": {
          "type": "integer",
          "format": "int32",
          "description": "Number of potential client instances or usage instances"
        },
        "capacitySize": {
          "description": "Identifies how the capacity size is to be interpreted : LIST is a discrete list of values, RANGE is a range in values etc...",
          "$ref": "#/definitions/CapacitySize"
        },
        "capacityCalculationRule": {
          "type": "string",
          "description": "Core logic that will be used on capacity calculation"
        },
        "source": {
          "type": "string",
          "description": "Source of the capacity"
        },
        "maxLimit": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum potential client instances"
        }
      }
    },
    "CapacityPattern": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Identifies Pattern type",
          "enum": ["LIST", "RANGE", "POOL", "PERCENTAGE"]
        },
        "format": {
          "type": "string",
          "description": "An optional regex expression or format string describing how to parse the size string in case of multiple values, e.g. CIR:EIR"
        }
      }
    },
    "CapacitySize": {
      "type": "object",
      "properties": {
        "size": {
          "type": "array",
          "description": "Capacity size to be interpreted with CapacityPattern",
          "items": {
            "type": "string"
          }
        },
        "pattern": {
          "description": "Identifies how the capacity size is to be interpreted : LIST is a discrete list of values, RANGE is a range in values etc...",
          "$ref": "#/definitions/CapacityPattern"
        },
        "unit": {
          "type": "string",
          "description": "unit for size string value"
        }
      }
    },
    "CascadedDtlTpePackage": {
      "type": "object",
      "properties": {
        "cascadedDtlIdTuple": {
          "type": "string",
          "description": "This field Cascaded DTL ID Tuple info.."
        }
      }
    },
    "ColorEntry": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the color"
        },
        "bitmask": {
          "type": "string",
          "description": "The 32-bit hexadecimal bitmask of the color"
        }
      }
    },
    "ColorGroup": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the color group"
        },
        "bitmask": {
          "type": "string",
          "description": "The 32-bit hexadecimal bitmask of the color group"
        },
        "colors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ColorEntry"
          }
        }
      }
    },
    "ConnectionPoint": {
      "type": "object",
      "properties": {
        "owningPoolAdapterType": {
          "type": "string",
          "description": "Type of the owner Adapter."
        },
        "dynamicOwningPoolAdapterFgiRules": {
          "type": "array",
          "description": "dynamicOwningPoolAdapterFgiRules",
          "items": {
            "type": "string"
          }
        },
        "mirroringBandwidthRules": {
          "type": "string",
          "description": "The mirroringBandwithRules for capacity calculation"
        },
        "mirroringNamingRules": {
          "type": "string",
          "description": "The mirroringNamingRules for capacity calculation"
        },
        "totalCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "usedCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "potentialGrowthCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "plannedCapacity": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "namingRules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NamingRules"
          }
        },
        "stitchingConstraint": {
          "type": "string",
          "description": "stitchingConstraint values",
          "enum": ["otnRegen"]
        }
      }
    },
    "ConnectionRule": {
      "type": "object",
      "properties": {
        "targetLayer": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "rule": {
          "type": "string",
          "description": "toServerUsingClientExternalFGRule matchers server's clientExternalFGRule",
          "enum": [
            "mustConnectInternally",
            "clientExternalFGRule",
            "connectsExternally",
            "toServerUsingClientExternalFGRule",
            "externalFGRule",
            "externalFGRuleViaImmediateClientPotential",
            "toDualPortPeerUsingClientExternalFGRule",
            "transitionalAtCreationTime"
          ]
        },
        "immediateClientPotential": {
          "type": "string",
          "description": "If describing connectionRulesInAdaptationLayer: names of TPESpec of immediate client TPE. If describing connectionRulesInOwnLayer: null (not relevant). If describing mustConnectInternally: null (not relevant)."
        },
        "immediateDualPortPeerPotential": {
          "type": "string",
          "description": "If describing connectionRulesInAdaptationLayer: names of TPESpec of dual port peer TPE. If describing connectionRulesInOwnLayer: null (not relevant). If describing mustConnectInternally: null (not relevant)."
        }
      }
    },
    "Constraints": {
      "type": "object",
      "properties": {
        "includeRouteObjects": {
          "type": "array",
          "description": "List of Route Objects to be included in the route calculation.",
          "items": {
            "$ref": "#/definitions/RouteObject"
          }
        },
        "excludeRouteObjects": {
          "type": "array",
          "description": "List of Route Objects to be excluded from the route calculation.",
          "items": {
            "$ref": "#/definitions/RouteObject"
          }
        },
        "customerCode": {
          "description": "Customer Code constraint as applicable for Design Request",
          "$ref": "#/definitions/CustomerCodeObject"
        },
        "diverseObjects": {
          "description": "Resource to define objects diverse from the route calculation.",
          "$ref": "#/definitions/DiversityObject"
        },
        "coRoutedService": {
          "type": "string",
          "description": "Co-routes the service with an existing service."
        }
      }
    },
    "ContinuousAdapterRulesPackage": {
      "type": "object",
      "properties": {
        "segmentationRule": {
          "type": "string",
          "description": "Whether the segment can be fragmented.",
          "enum": ["oneSegementInGroup"]
        },
        "widthRule": {
          "type": "string",
          "description": "How wide the range can be. Can point to a specific algorithm to be executed.",
          "enum": ["mediaChannelWidthRule", "nmcWidthRule"]
        },
        "lowerBoundaryRule": {
          "type": "string",
          "description": "Rule that the boundary of the range must follow. Can point to a specific algorithm to be executed.",
          "enum": [
            "mustSnapTo6_25GHzGrid_0_768",
            "mustSnapTo37_5GHzGrid_0_96",
            "snapTo6_25GHzGrid",
            "snapTo50GHzGrid",
            "snapTo100GHzGrid",
            "snapTo75GHzGrid"
          ]
        },
        "upperBoundaryRule": {
          "type": "string",
          "description": "Rule that the boundary of the range must follow. Can point to a specific algorithm to be executed.",
          "enum": [
            "mustSnapTo6_25GHzGrid_0_768",
            "mustSnapTo37_5GHzGrid_0_96",
            "snapTo6_25GHzGrid",
            "snapTo50GHzGrid",
            "snapTo100GHzGrid",
            "snapTo75GHzGrid"
          ]
        },
        "centerFrequencyRule": {
          "type": "string",
          "description": "Rule that the centerFrequency of the range must follow. Can point to a specific algorithm to be executed.",
          "enum": ["transponderResolution"]
        }
      }
    },
    "ControlPlanePackage": {
      "type": "object",
      "properties": {
        "osrpCommChannel": {
          "type": "string",
          "description": "communication carrier.",
          "enum": ["GCC0", "GCC1", "GCC2", "GCC12"]
        },
        "ovpnIds": {
          "type": "array",
          "description": "The optical virtual private network ID list",
          "items": {
            "type": "string"
          }
        },
        "applicableRates": {
          "type": "string",
          "description": "Applicable Rates list"
        },
        "holdBackSdThresholds": {
          "type": "string",
          "description": "Holdback signal degrade threshold"
        },
        "bwThresholdMode": {
          "type": "string",
          "description": "The default setting of OSRP link bandwidth threshold mode",
          "enum": ["ADV_ALL", "AUTO", "MANUAL"]
        },
        "commonId": {
          "type": "integer",
          "format": "int32",
          "description": "Common identifier of the OSRP line"
        },
        "holdOffTimer": {
          "type": "integer",
          "format": "int32",
          "description": "Line-Level hold-off timer "
        },
        "configuredLatencyType": {
          "type": "string",
          "description": "Describe whether the latency is discovered or  manual.",
          "enum": ["disc", "manual"]
        },
        "isMaster": {
          "type": "boolean",
          "description": "Specifies if this end of the OSRP link is the master.",
          "default": false
        },
        "commState": {
          "type": "string",
          "description": "State of the Hello protocol finite state machine."
        },
        "bwLockOut": {
          "type": "string",
          "description": "Specifies if bandwidth lockout is enabled locally for the OSRP line.",
          "enum": ["NO", "YES"]
        },
        "bwThreshold": {
          "$ref": "#/definitions/BandwidthThreshold"
        }
      }
    },
    "CustomerCodeObject": {
      "type": "object",
      "properties": {
        "codes": {
          "type": "array",
          "description": "List of CustomerCode in decreasing order of priority",
          "items": {
            "type": "string"
          }
        },
        "unorderedList": {
          "type": "boolean",
          "description": "Attribute to specify that code list is unordered.",
          "default": false
        }
      }
    },
    "DeviceAlias": {
      "type": "object",
      "properties": {
        "aliasType": {
          "type": "string",
          "description": "The type of this device alias instance.",
          "enum": ["TID", "IP_ADDRESS", "MAC_ADDRESS", "PLANNING_ID", "CUSTOM"]
        },
        "name": {
          "type": "string",
          "description": "The text representation of this device alias."
        },
        "patternFormat": {
          "type": "string",
          "description": "An optional regex pattern for custom alias."
        }
      }
    },
    "Diagnostic": {
      "type": "object",
      "properties": {
        "diagnosticType": {
          "type": "string",
          "enum": ["PM_TEST"]
        },
        "pmType": {
          "type": "string",
          "enum": ["PREFEC_BER", "PM_RESET_UNTIMED", "PM_RESET_BASELINE"]
        },
        "degradeThreshold": {
          "type": "number",
          "format": "double",
          "description": "(Optional) The pre-FEC BER lower threshold"
        },
        "failThreshold": {
          "type": "number",
          "format": "double",
          "description": "(Optional) The pre-FEC BER higher threshold"
        }
      }
    },
    "DiagnosticStatus": {
      "type": "object",
      "properties": {
        "diagnosticType": {
          "type": "string",
          "enum": ["PM_TEST"]
        },
        "pmType": {
          "type": "string",
          "enum": ["PREFEC_BER", "PM_RESET_UNTIMED", "PM_RESET_BASELINE"]
        },
        "state": {
          "type": "string",
          "description": "State of the Diagnostic Test",
          "enum": [
            "WAITING_FOR_ACTIVATED_SERVICE",
            "WAITING_FOR_SERVICE_TRAFFIC",
            "IN_PROGRESS",
            "ERROR",
            "PASS",
            "FAIL",
            "MARGINAL"
          ]
        }
      }
    },
    "DiagnosticStatuses": {
      "type": "object",
      "properties": {
        "diagnosticStatuses": {
          "type": "array",
          "description": "A status list of performance monitoring (PM) and diagnostic tests",
          "items": {
            "$ref": "#/definitions/DiagnosticStatus"
          }
        }
      }
    },
    "Diagnostics": {
      "type": "object",
      "properties": {
        "diagnostics": {
          "type": "array",
          "description": "A list of performance monitoring (PM) and diagnostic tests",
          "items": {
            "$ref": "#/definitions/Diagnostic"
          }
        }
      }
    },
    "DiversityObject": {
      "type": "object",
      "properties": {
        "srlgDiverse": {
          "type": "boolean",
          "description": "Attribute to specify SRLG diversity.",
          "default": false
        },
        "siteDiverse": {
          "type": "boolean",
          "description": "Attribute to specify site diversity.",
          "default": false
        },
        "nodeDiverse": {
          "type": "boolean",
          "description": "Attribute to specify node diversity.",
          "default": false
        },
        "existingService": {
          "type": "array",
          "description": "The existing service user label list.",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "Error": {
      "type": "object",
      "properties": {
        "errorCode": {
          "type": "string"
        },
        "errorMessage": {
          "type": "string"
        },
        "errorDescription": {
          "type": "string"
        },
        "msgAttributes": {
          "type": "object",
          "additionalProperties": {
            "type": "object"
          }
        },
        "meta": {
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Errors": {
      "type": "object",
      "properties": {
        "errors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Error"
          }
        }
      }
    },
    "G8032Package": {
      "type": "object",
      "properties": {
        "ringId": {
          "type": "string",
          "description": "The logical ring ID"
        },
        "logicalRingName": {
          "type": "string",
          "description": "The logical ring name"
        },
        "virtualRingName": {
          "type": "string",
          "description": "the virtual ring name"
        },
        "rapsVid": {
          "type": "string",
          "description": "the R-APS VID of the ring"
        },
        "rplOwner": {
          "type": "boolean",
          "description": "True if the port is configured as RPL-owner.",
          "default": false
        },
        "operationalChannelBlock": {
          "type": "boolean",
          "description": "True if the port is blocked, i.e portState == Blocked",
          "default": false
        },
        "ringType": {
          "type": "string",
          "description": "the type of ring",
          "enum": ["majorRing", "subRing"]
        },
        "sharedPort": {
          "type": "string",
          "description": "sharedPort information for the sub-ring (ONLY for sub-ring endNode)"
        },
        "sharedPortRef": {
          "type": "string",
          "description": "the ID of the PTP on the shared port"
        },
        "forceSwitch": {
          "type": "boolean",
          "description": "a flag indicating whether the switching is forced or not.",
          "default": false
        },
        "subRingTermination": {
          "type": "boolean",
          "description": "flag indicating whether the subring is terminating or not",
          "default": false
        },
        "portDirection": {
          "type": "string",
          "description": "the direction of the port.",
          "enum": ["east", "west"]
        },
        "revertive": {
          "type": "boolean",
          "description": "revertive",
          "default": false
        },
        "holdOffTime": {
          "type": "integer",
          "format": "int32",
          "description": "hold off time in milliseconds"
        },
        "holdOffTimeUnit": {
          "type": "string",
          "description": "Unit of time",
          "enum": ["min", "sec", "msec"]
        },
        "waitToRestore": {
          "type": "integer",
          "format": "int32",
          "description": "wait to restore time in minute. "
        },
        "waitToRestoreUnit": {
          "type": "string",
          "description": "Unit of time",
          "enum": ["min", "sec", "msec"]
        },
        "waitToBlock": {
          "type": "integer",
          "format": "int32",
          "description": "wait to block time in milliseconds. "
        },
        "waitToBlockUnit": {
          "type": "string",
          "description": "Unit of time",
          "enum": ["min", "sec", "msec"]
        },
        "guardTime": {
          "type": "integer",
          "format": "int32",
          "description": "guard time in millisecond."
        },
        "guardTimeUnit": {
          "type": "string",
          "description": "Unit of time",
          "enum": ["min", "sec", "msec"]
        },
        "ringMembers": {
          "type": "string",
          "description": "a comma separated list of virtual ring members."
        },
        "ringState": {
          "type": "string",
          "description": "the state of the ring",
          "enum": [
            "initializing",
            "ok",
            "adminDisabled",
            "operationalDisabled",
            "protecting",
            "recovering",
            "unknown"
          ]
        },
        "ringStatus": {
          "type": "string",
          "description": "the status of the ring",
          "enum": [
            "ok",
            "localSignalFailure",
            "localForceSwitch",
            "remoteOtherPortSignalFailure",
            "remoteOtherPortForceSwitch",
            "provisioningMismatch",
            "notReceivingPDUS",
            "noRPLOwnerDetected",
            "unknown"
          ]
        },
        "portState": {
          "type": "string",
          "description": "the state of the port",
          "enum": ["disabled", "forwarding", "blocked", "unknown"]
        },
        "portStatus": {
          "type": "string",
          "description": "the status of the port",
          "enum": [
            "ok",
            "down",
            "CCMFailure",
            "localForceSwitch",
            "remoteForceSwitch",
            "remoteSignalFailure",
            "unknown"
          ]
        }
      }
    },
    "Header": {
      "type": "object",
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HeaderElement"
          }
        },
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "HeaderElement": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "parameterCount": {
          "type": "integer",
          "format": "int32"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NameValuePair"
          }
        }
      }
    },
    "HopEntry": {
      "type": "object",
      "properties": {
        "hopAddress": {
          "type": "string",
          "description": "The IP-data interface address for this hop"
        },
        "hopType": {
          "type": "string",
          "description": "The type of this hop",
          "enum": ["strict", "loose"]
        }
      }
    },
    "HttpEntity": {
      "type": "object",
      "properties": {
        "contentLength": {
          "type": "integer",
          "format": "int64"
        },
        "contentType": {
          "$ref": "#/definitions/Header"
        },
        "contentEncoding": {
          "$ref": "#/definitions/Header"
        },
        "repeatable": {
          "type": "boolean",
          "default": false
        },
        "chunked": {
          "type": "boolean",
          "default": false
        },
        "streaming": {
          "type": "boolean",
          "default": false
        },
        "content": {
          "$ref": "#/definitions/InputStream"
        }
      }
    },
    "HttpParams": {
      "type": "object"
    },
    "HttpResponse": {
      "type": "object",
      "properties": {
        "locale": {
          "$ref": "#/definitions/Locale"
        },
        "statusLine": {
          "$ref": "#/definitions/StatusLine"
        },
        "entity": {
          "$ref": "#/definitions/HttpEntity"
        },
        "params": {
          "$ref": "#/definitions/HttpParams"
        },
        "allHeaders": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Header"
          }
        },
        "protocolVersion": {
          "$ref": "#/definitions/ProtocolVersion"
        }
      }
    },
    "Indexes": {
      "type": "object"
    },
    "InputStream": {
      "type": "object"
    },
    "IpInterfacePackage": {
      "type": "object",
      "properties": {
        "bfd": {
          "description": "Holds BFD attributes for TPE endpoint",
          "$ref": "#/definitions/Bfd"
        },
        "isis": {
          "description": "Holds IsIs attributes",
          "$ref": "#/definitions/IsIs"
        }
      }
    },
    "IsIs": {
      "type": "object",
      "properties": {
        "instance-tag": {
          "type": "string",
          "description": "Protocol instance Tag"
        },
        "levels": {
          "type": "array",
          "description": "Contains IsIs Level attribute details",
          "items": {
            "$ref": "#/definitions/IsIsLevelData"
          }
        },
        "interfaceType": {
          "type": "string",
          "description": "point-to-point or point-to-multipoint network"
        },
        "bfdEnabled": {
          "type": "boolean",
          "description": "Bidirectional forwarding detection for ISIS",
          "default": false
        }
      }
    },
    "IsIsLevelData": {
      "type": "object",
      "properties": {
        "levelType": {
          "type": "string",
          "description": "Level of an IS-IS node - can be level-1, level-2 or level-1-2"
        },
        "linkCost": {
          "type": "integer",
          "format": "int32",
          "description": "Cost associated with the links having range 1-63, i.e. default-10, delay, expense etc."
        },
        "lfaCandidateEnable": {
          "type": "boolean",
          "description": "Enable/disable the interface from being used as LFA for level-1, level-2 or level-1-2 primary route",
          "default": false
        }
      }
    },
    "ItsPackage": {
      "type": "object",
      "properties": {
        "itsMode": {
          "type": "string",
          "description": "Specify supported ITS mode"
        }
      }
    },
    "LayerProtocol": {
      "type": "object",
      "properties": {
        "termination": {
          "description": "The specification of the layer protocol termination (including framing, modulation etc). For example the specification of the function that takes a MAC frame and extracts the content (removing the MAC address in the process).",
          "$ref": "#/definitions/Termination"
        },
        "adaptationPools": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AdaptationPool"
          }
        },
        "layeredAttributes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LayeredAttribute"
          }
        },
        "accessPoint": {
          "$ref": "#/definitions/AccessPoint"
        },
        "connectionPoint": {
          "$ref": "#/definitions/ConnectionPoint"
        },
        "tandemConnectionMonitoring": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TandemConnectionMonitoring"
          }
        }
      }
    },
    "LayerTermination": {
      "type": "object",
      "properties": {
        "layerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "nativeLayerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "dynamicLayerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "layerRateQualifier": {
          "type": "string",
          "description": "Provides a means to provide additional qualification attributes for a Layer Rate. For example, for beyond 100G rates OTUCn and ODUCn, the value of n, where n is a multiple of 100. For example, for beyond 100G rates with sub rate potential (i.e. OTUCn-M), this includes the n-M options where n is the number of OxUC overhead instances and M is the number of 5G tributary slots. For example, OTUC4-60 implies 4 instances of OxUC overhead, and 300G capacity (5G x 60).",
          "enum": [
            "ODUC1",
            "ODUC2",
            "ODUC2_25",
            "ODUC2_30",
            "ODUC3",
            "ODUC4",
            "ODUC4_60",
            "ODUC4_70",
            "ODUC5",
            "ODUC6",
            "ODUC7",
            "ODUC8",
            "OTUC1",
            "OTUC2",
            "OTUC2_25",
            "OTUC2_30",
            "OTUC3",
            "OTUC3_50",
            "OTUC4",
            "OTUC4_60",
            "OTUC5",
            "OTUC6",
            "OTUC7",
            "OTUC8",
            "OC3",
            "OC12",
            "OC48",
            "OC192",
            "OC768",
            "STM1",
            "STM4",
            "STM16",
            "STM64",
            "STM256",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "_1GE",
            "_10GE",
            "_40GE",
            "_100GE",
            "_400GE",
            "_2G5",
            "_1G25",
            "_10G",
            "_40G",
            "_100G",
            "_150G",
            "_200G",
            "_250G",
            "_300G",
            "_350G",
            "_400G",
            "_500G",
            "_600G",
            "_700G",
            "_800G",
            "ETHFLEX",
            "FICON1G",
            "FICONEXPRESS2G",
            "FICON4G",
            "FICON8G",
            "FICON16G",
            "FC100",
            "FC200",
            "FC400",
            "FC800",
            "FC1200",
            "FC1600",
            "FC3200",
            "UNKNOWN"
          ]
        },
        "structureType": {
          "type": "string",
          "description": "Identifies the internal structure of the layer termination.",
          "enum": [
            "dual_port",
            "dual_port_client_mapping",
            "exposed_lone_cp",
            "lone_adapter",
            "full_layer_optional_exposed_cp",
            "full_layer_optional_exposed_cp_and_tcp",
            "full_layer_fixed",
            "exposed_tcp",
            "concatenating_adapter",
            "concatenatable_exposed_tcp",
            "layer_termination_structure_type_unknown",
            "concatenatable_fixed",
            "exposed_TCP_and_CP"
          ]
        },
        "terminationState": {
          "type": "string",
          "description": "Whether and how this LayerTermination is terminated.",
          "enum": [
            "layer_termination_cannot_terminate",
            "layer_termination_not_terminated",
            "terminated_server_to_client_flow",
            "terminated_client_to_server_flow",
            "terminated_bidirectional",
            "layer_termination_permanently_terminated",
            "termination_state_unknown"
          ]
        },
        "adminState": {
          "type": "string",
          "description": "The administrative state of the layer termination.",
          "enum": ["up", "down"]
        },
        "operationalState": {
          "type": "string",
          "description": "The operational (actual) state of the layer termination.",
          "enum": ["up", "down", "link_flapping", "abnormal"]
        },
        "active": {
          "type": "boolean",
          "description": "Whether or not an inactive layer appears to be absent from the layer stack.",
          "default": false
        },
        "adjacencyPackage": {
          "description": "This package stores layer adjacency information.",
          "$ref": "#/definitions/AdjacencyPackage"
        },
        "retainedAdjacencyPackage": {
          "description": "This package stores layer adjacency information.",
          "$ref": "#/definitions/AdjacencyPackage"
        },
        "manualAdjacencyPackage": {
          "description": "This package stores layer adjacency information.",
          "$ref": "#/definitions/AdjacencyPackage"
        },
        "powerPackage": {
          "description": "This package stores power related information.",
          "$ref": "#/definitions/PowerPackage"
        },
        "photonicSpectrumPackage": {
          "description": "This package stores photonic spectrum information.",
          "$ref": "#/definitions/PhotonicSpectrumPackage"
        },
        "cfmPackages": {
          "type": "array",
          "description": "Holds data related to CFM services configured on an Ethernet service",
          "items": {
            "$ref": "#/definitions/TpeCfmPackage"
          }
        },
        "mplsPackage": {
          "description": "This package stores MPLS tunnel information.",
          "$ref": "#/definitions/MplsPackage"
        },
        "g8032Package": {
          "description": "This package stores information about the G8032 ring",
          "$ref": "#/definitions/G8032Package"
        },
        "signalIndex": {
          "description": "Attribute representing a signal index (e.g. channel information, wavelength, etc).",
          "$ref": "#/definitions/SignalIndex"
        },
        "nativeName": {
          "type": "string",
          "description": "The name of the TPE that is native to the network element."
        },
        "layerProtocol": {
          "description": "A LayerProtocol instance is used for controlling termination and monitoring functionality. Also, it is used for controlling the adaptation (i.e. encapsulation and/or multiplexing of client signal), tandem connection monitoring, traffic conditioning and/or shaping functionality at an intermediate point along a connection.",
          "$ref": "#/definitions/LayerProtocol"
        },
        "trafficProfiles": {
          "type": "array",
          "description": "Traffic profile characteristics used to data-drive provisioning workflows.",
          "items": {
            "$ref": "#/definitions/TrafficProfile"
          }
        },
        "serviceLabel": {
          "type": "string",
          "description": "The service-identifiying label"
        },
        "boundaries": {
          "type": "array",
          "description": "Array of strings to track boundaries of Layer Termination",
          "items": {
            "type": "string"
          }
        },
        "ttiPackage": {
          "description": "This package stores Tti information.",
          "$ref": "#/definitions/TtiPackage"
        },
        "controlPlanePackage": {
          "description": "The northbound model of Control Plane Package.",
          "$ref": "#/definitions/ControlPlanePackage"
        },
        "resiliencyTopologyPackage": {
          "description": "This package stores resiliency topology information.",
          "$ref": "#/definitions/ResiliencyTopologyPackage"
        },
        "adminWt": {
          "type": "number",
          "format": "double",
          "description": "Administrative weight which specifies the level of importance given to the OSRP link"
        },
        "bundleIds": {
          "type": "array",
          "description": "List of up to 20 protection bundles to which the OSRP link belongs",
          "items": {
            "type": "string"
          }
        },
        "latency": {
          "type": "number",
          "format": "double",
          "description": "Indicates the delay in microseconds."
        },
        "bgpPackage": {
          "description": "This package stores BGP information.",
          "$ref": "#/definitions/BgpPackage"
        },
        "additionalAttributes": {
          "description": "Various miscellaneous attributes that do not necessarily belong in the parent resource. Attributes are populated dynamically and therefore cannot be documented here.",
          "$ref": "#/definitions/AdditionalAttributes"
        },
        "txInfo": {
          "description": "TxInfo",
          "$ref": "#/definitions/TxInfo"
        },
        "ipInterfacePackage": {
          "description": "To report IP settings on the interface",
          "$ref": "#/definitions/IpInterfacePackage"
        }
      }
    },
    "LayeredAttribute": {
      "type": "object",
      "properties": {
        "layer": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "additionalAttributes": {
          "description": "Various miscellaneous attributes that do not necessarily belong in the parent resource. Attributes are populated dynamically and therefore cannot be documented here.",
          "$ref": "#/definitions/AdditionalAttributes"
        },
        "loopbackPackage": {
          "description": "This package stores loopback information",
          "$ref": "#/definitions/LoopbackPackage"
        },
        "itsPackage": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ItsPackage"
          }
        }
      }
    },
    "LifeCycleRule": {
      "type": "object",
      "properties": {
        "autoCreatedByNetwork": {
          "type": "boolean",
          "description": "Indicates if the entity is auto created by the network and/or device (true) or must it explicitly be created (false).",
          "default": false
        },
        "autoDeletedByNetwork": {
          "type": "boolean",
          "description": "Indicates if the entity is auto deleted by the network and/or device (true) or must it explicitly be created (false).",
          "default": false
        }
      }
    },
    "LinkAttributes": {
      "type": "object",
      "properties": {
        "tags": {
          "type": "array",
          "description": "Reference to 3rd Party Network involved in this topology, can be re-used for other purposes in future.",
          "items": {
            "type": "string"
          }
        },
        "description": {
          "type": "string",
          "description": "Short description of the topology to be created."
        },
        "userLabel": {
          "type": "string",
          "description": "The user label (not necessarily unique) of the topology to be created."
        },
        "note": {
          "$ref": "#/definitions/Note"
        }
      }
    },
    "Locale": {
      "type": "object",
      "properties": {
        "language": {
          "type": "string"
        },
        "script": {
          "type": "string"
        },
        "country": {
          "type": "string"
        },
        "variant": {
          "type": "string"
        },
        "extensionKeys": {
          "type": "array",
          "uniqueItems": true,
          "items": {
            "type": "string"
          }
        },
        "unicodeLocaleAttributes": {
          "type": "array",
          "uniqueItems": true,
          "items": {
            "type": "string"
          }
        },
        "unicodeLocaleKeys": {
          "type": "array",
          "uniqueItems": true,
          "items": {
            "type": "string"
          }
        },
        "iso3Language": {
          "type": "string"
        },
        "iso3Country": {
          "type": "string"
        },
        "displayLanguage": {
          "type": "string"
        },
        "displayScript": {
          "type": "string"
        },
        "displayCountry": {
          "type": "string"
        },
        "displayVariant": {
          "type": "string"
        },
        "displayName": {
          "type": "string"
        }
      }
    },
    "Location": {
      "type": "object",
      "properties": {
        "mgmtAccess": {
          "type": "string",
          "description": "The management access used to specify or discover the location.",
          "enum": ["tl1", "saos"]
        },
        "address": {
          "type": "array",
          "description": "The location is comprised of one or more address datums. For example, many cards are identified with with both a shelf and a slot address.",
          "items": {
            "$ref": "#/definitions/LocationAddress"
          }
        }
      }
    },
    "LocationAddress": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "The type of the address location.",
          "enum": ["RACK", "SHELF", "SUBSHELF", "SLOT", "SUBSLOT", "PORT"]
        },
        "value": {
          "type": "string",
          "description": "int or character value as appropriate to the associated entity and field."
        },
        "pattern": {
          "type": "string",
          "description": "optional regex or delimiter value to parse multi-valued subslot string."
        }
      }
    },
    "LoopbackPackage": {
      "type": "object",
      "properties": {
        "loopbackStatus": {
          "type": "string",
          "description": "Status of the test; taken directly from the value of the TL1 LPBKSTATUS field."
        },
        "loopbackWavelength": {
          "type": "string",
          "description": "Wavelength of the loopback test; taken directly from the value of the TL1 LPBKWVL field"
        }
      }
    },
    "MapperRule": {
      "type": "object",
      "properties": {
        "groupedTribSlots": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "tribSlots": {
          "type": "array",
          "description": "Mapped tributary slots corresponding to tributary port",
          "items": {
            "type": "string"
          }
        },
        "tribPort": {
          "type": "string",
          "description": "Tributary port"
        }
      }
    },
    "MappingInteractionRule": {
      "type": "object",
      "properties": {
        "segmentBoundaryRule": {
          "type": "string",
          "description": "The default is mustNotOverlap.",
          "enum": ["mustNotOverlap"]
        }
      }
    },
    "MappingTableEntry": {
      "type": "object",
      "properties": {
        "direction": {
          "type": "string",
          "description": "The directionality defined in terms of RX/TX.",
          "enum": ["RX", "TX", "RXTX"]
        },
        "label": {
          "type": "string",
          "description": "The user label."
        },
        "cos": {
          "type": "string",
          "description": "The class of service."
        },
        "ip": {
          "type": "string",
          "description": "The ip address."
        }
      }
    },
    "MbbHistoryEntry": {
      "type": "object",
      "properties": {
        "startTime": {
          "type": "string",
          "description": "Start time of the make-before-break happened"
        },
        "endTime": {
          "type": "string",
          "description": "End time of the make-before-break happened"
        },
        "result": {
          "type": "string",
          "description": "Result of the make-before-break"
        },
        "reason": {
          "type": "string",
          "description": "Reason of the make-before-break"
        }
      }
    },
    "MepEntry": {
      "type": "object",
      "properties": {
        "mepId": {
          "type": "string",
          "description": "The ID of the MEP"
        },
        "ccmTransmitState": {
          "type": "string",
          "description": "The transmission state of CCM (on/off)",
          "enum": ["ON", "OFF"]
        },
        "mepAdminState": {
          "type": "string",
          "description": "The administrative state (enabled/disabled) of the MEP",
          "enum": ["ENABLED", "DISABLED"]
        },
        "mepType": {
          "type": "string",
          "description": "The type of the MEP, up or down",
          "enum": ["UP", "DOWN"]
        },
        "mepMacAddress": {
          "type": "string",
          "description": "The MAC address of the MEP"
        },
        "ccmPriority": {
          "type": "string",
          "description": "Priority of the CC messages (0-7)"
        },
        "vlanId": {
          "type": "string",
          "description": "The VLAN ID of the MEP"
        },
        "lmm": {
          "description": "Holds Y.1731 attributes for one measurement type of a MEP",
          "$ref": "#/definitions/Y1731Attributes"
        },
        "dmm": {
          "description": "Holds Y.1731 attributes for one measurement type of a MEP",
          "$ref": "#/definitions/Y1731Attributes"
        },
        "slm": {
          "description": "Holds Y.1731 attributes for one measurement type of a MEP",
          "$ref": "#/definitions/Y1731Attributes"
        },
        "remoteMepId": {
          "type": "string",
          "description": "The ID of the remote MEP"
        }
      }
    },
    "MplsFb": {
      "type": "object",
      "properties": {
        "frrAutoCreated": {
          "type": "boolean",
          "description": "The flag indicating whether the FB tunnel is auto created by FRR",
          "default": false
        },
        "protectedInterface": {
          "type": "string",
          "description": "Name of the interface being protected by the FB tunnel"
        },
        "excludeIp": {
          "type": "string",
          "description": "IP address excluded from the FB tunnel path"
        },
        "protectedTunnels": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MplsFbProtectedTunnel"
          }
        }
      }
    },
    "MplsFbProtectedTunnel": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the tunnel protected by this FB tunnel"
        },
        "srcIp": {
          "type": "string",
          "description": "Source IP address of the tunnel protected by this FB tunnel"
        },
        "destIp": {
          "type": "string",
          "description": "Destination IP address of the tunnel protected by this FB tunnel"
        },
        "role": {
          "type": "string",
          "description": "The role at this point of the MPLS tunnel protected by this FB tunnel",
          "enum": ["ingress", "transit"]
        }
      }
    },
    "MplsFrr": {
      "type": "object",
      "properties": {
        "frrProtected": {
          "type": "boolean",
          "description": "If true, the tunnel is protected by fast re-route (FRR) on the headend TX MPLS CTP",
          "default": false
        },
        "profileName": {
          "type": "string",
          "description": "The FRR profile name on the headend TX MPLS CTP"
        },
        "localProtection": {
          "description": "Holds MPLS FRR local protection attributes for TX MPLS CTP",
          "$ref": "#/definitions/MplsFrrLocalProtection"
        },
        "actualProtectionRoute": {
          "type": "array",
          "description": "Actual FRR protection route on the headend TX MPLS CTP",
          "items": {
            "$ref": "#/definitions/MplsFrrProtectionRouteHop"
          }
        }
      }
    },
    "MplsFrrLocalProtection": {
      "type": "object",
      "properties": {
        "protectionAvailable": {
          "type": "boolean",
          "description": "True when the protection is available on this endpoint",
          "default": false
        },
        "protectionInUse": {
          "type": "boolean",
          "description": "True when the protection is in use on this endpoint",
          "default": false
        },
        "protectionFbName": {
          "type": "string",
          "description": "Protection FB tunnel name"
        }
      }
    },
    "MplsFrrProtectionRouteHop": {
      "type": "object",
      "properties": {
        "ip": {
          "type": "string",
          "description": "IP interface address or node loopback IP address of the current hop"
        },
        "protectionType": {
          "type": "string",
          "description": "The FB protection type on this hop for this unidirectional tunnel",
          "enum": ["none", "link_protect", "node_protect"]
        },
        "protectionInUse": {
          "type": "boolean",
          "description": "True when the protection is in use on this endpoint",
          "default": false
        },
        "bwProtected": {
          "type": "boolean",
          "description": "True when the bandwidth is protected on this endpoint",
          "default": false
        }
      }
    },
    "MplsPackage": {
      "type": "object",
      "properties": {
        "lspName": {
          "type": "string",
          "description": "The name of this MPLS tunnel"
        },
        "lspId": {
          "type": "string",
          "description": "The numeric ID of this MPLS tunnel"
        },
        "coRouted": {
          "type": "boolean",
          "description": "If true, this MPLS tunnel is co-routed; otherwise it is associated",
          "default": false
        },
        "signaled": {
          "type": "boolean",
          "description": "If true, this MPLS tunnel is dynamic; otherwise it is static",
          "default": false
        },
        "subType": {
          "type": "string",
          "description": "TP refers to Transport Profile; TE refers to Traffic Engineering",
          "enum": ["TP", "TE"]
        },
        "direction": {
          "type": "string",
          "description": "Tunnel direction. Use value bidirectional or unidirectional only and TPE attribute stackDirection since ingress and egress are ambiguous",
          "enum": ["bidirectional", "ingress", "egress", "unidirectional"]
        },
        "tunnelType": {
          "type": "string",
          "description": "Tunnel type (static/dynamic, ingress/egress, corouted/unidrectional)",
          "enum": [
            "rsvp_ingress_corout",
            "rsvp_egress_corout",
            "rsvp_transit_corout",
            "static_ingress_corout",
            "static_egress_corout",
            "static_transit_corout",
            "static_ingress_unidir",
            "static_egress_unidir",
            "static_transit_unidir",
            "rsvp_ingress_unidir",
            "rsvp_transit_unidir",
            "static_ingress_assoc",
            "rsvp_ingress",
            "rsvp_transit",
            "rsvp_egress"
          ]
        },
        "ctrlPlaneId": {
          "type": "string",
          "description": "A generated value to uniquely identify a particular tunnel instance"
        },
        "srcIp": {
          "type": "string",
          "description": "The IP-data interface address of the near end of this MPLS tunnel"
        },
        "srcTunnelId": {
          "type": "string",
          "description": "The ID of the near end of this MPLS tunnel"
        },
        "destIp": {
          "type": "string",
          "description": "The IP-data interface address of the far end of this MPLS tunnel"
        },
        "destTunnelId": {
          "type": "string",
          "description": "The ID of the far end of this MPLS tunnel"
        },
        "fwdIn": {
          "type": "string",
          "description": "The inward ID in the forward direction (transit)"
        },
        "fwdOut": {
          "type": "string",
          "description": "The outward ID in the forward direction (transit)"
        },
        "revIn": {
          "type": "string",
          "description": "The inward ID in the reverse direction (transit)"
        },
        "revOut": {
          "type": "string",
          "description": "The outward ID in the reverse direction (transit)"
        },
        "prevHopIp": {
          "type": "string",
          "description": "The interface address (on 6200, MAC address) of the previous hop of this MPLS tunnel"
        },
        "nextHopIp": {
          "type": "string",
          "description": "The interface address (on 6200, MAC address) of the next hop of this MPLS tunnel"
        },
        "prevHopIfNum": {
          "type": "string",
          "description": "The interface number of the previous hop of this MPLS tunnel"
        },
        "nextHopIfNum": {
          "type": "string",
          "description": "The interface number of the next hop of this MPLS tunnel"
        },
        "localIfNamePrevHop": {
          "type": "string",
          "description": "The local interface name of the previous hop of this MPLS tunnel (6200 only)"
        },
        "localIfNameNextHop": {
          "type": "string",
          "description": "The local interface name of the next hop of this MPLS tunnel (6200 only)"
        },
        "RxTag": {
          "type": "string",
          "description": "The label used for traffic ingressing to this endpoint"
        },
        "TxTag": {
          "type": "string",
          "description": "The label used for traffic egressing from this endpoint"
        },
        "tunnelRole": {
          "type": "string",
          "description": "The role at this point in the MPLS tunnel",
          "enum": ["headEnd", "tailEnd", "transit"]
        },
        "bw": {
          "description": "Holds bandwidth attributes for a dynamic tunnel endpoint or an IP interface",
          "$ref": "#/definitions/Bw"
        },
        "autoBackup": {
          "type": "string",
          "description": "A flag to signal if auto-backup tunnel creation is on or off",
          "enum": ["on", "off"]
        },
        "diversityResource": {
          "type": "string",
          "description": "The object upon which to base diversity for the backup tunnel",
          "enum": [
            "unknown",
            "none",
            "link",
            "srlg",
            "node",
            "srlg_and_node",
            "srlg_and_link",
            "link_and_node",
            "srlg_or_node",
            "srlg_and_link_and_node"
          ]
        },
        "diversityLevel": {
          "type": "string",
          "description": "The diversity level of backup tunnel creation (maximal meaning best-effort)",
          "enum": ["strict", "maximal"]
        },
        "explicitRouteObject": {
          "type": "array",
          "description": "An ordered list of hop-by-hop IP-data interface addresses traversed by this dynamic MPLS tunnel",
          "items": {
            "type": "string"
          }
        },
        "bfd": {
          "description": "Holds BFD attributes for one LER TPE endpoint",
          "$ref": "#/definitions/Bfd"
        },
        "aisProfileName": {
          "type": "string",
          "description": "The name of the Alarm Indication Signal profile for this MPLS tunnel"
        },
        "aisSessionAdminState": {
          "type": "string",
          "description": "The administrative state of the AIS session for this MPLS tunnel",
          "enum": ["up", "down"]
        },
        "aisRefreshTimer": {
          "type": "integer",
          "format": "int32",
          "description": "The interval between each AIS refresh for this MPLS tunnel"
        },
        "aisRefreshTimerUnit": {
          "type": "string",
          "description": "The units for aisRefreshTimer field"
        },
        "frrSignaling": {
          "type": "string",
          "description": "Deprecated by frr package and will be removed later. Flag for fast re-route capability",
          "enum": ["on", "off"]
        },
        "frrProfile": {
          "type": "string",
          "description": "Deprecated by frr package and will be removed later. The fast re-route profile for this MPLS tunnel",
          "enum": ["none", "link_protect", "node_protect"]
        },
        "explicitTunnel": {
          "description": "Holds data for the explicit tunnel path",
          "$ref": "#/definitions/TunnelPath"
        },
        "fixedTtl": {
          "type": "string",
          "description": "The time-to-live for tunnel hops (1-255)"
        },
        "setupPriority": {
          "type": "string",
          "description": "The priority of the dynamic tunnel setup (0-7)"
        },
        "holdPriority": {
          "type": "string",
          "description": "The priority of the dynamic tunnel steady-state (0-7)"
        },
        "optimization": {
          "type": "string",
          "description": "A flag indicating if tunnel optimization should be attempted by the control-plane",
          "enum": ["on", "off"]
        },
        "optimizationInterval": {
          "type": "integer",
          "format": "int32",
          "description": "The interval between tunnel optimization attempts"
        },
        "optimizationIntervalUnit": {
          "type": "string",
          "description": "The unit for optimizationInterval"
        },
        "srlg": {
          "type": "array",
          "description": "A list of shared-risk link-group values assigned to this interface",
          "items": {
            "type": "string"
          }
        },
        "colorGroup": {
          "description": "The color group for a dynamic tunnel endpoint",
          "$ref": "#/definitions/ColorGroup"
        },
        "includeAny": {
          "description": "The color group for a dynamic tunnel endpoint",
          "$ref": "#/definitions/ColorGroup"
        },
        "includeAll": {
          "description": "The color group for a dynamic tunnel endpoint",
          "$ref": "#/definitions/ColorGroup"
        },
        "excludeAny": {
          "description": "The color group for a dynamic tunnel endpoint",
          "$ref": "#/definitions/ColorGroup"
        },
        "facilityBypass": {
          "type": "boolean",
          "description": "If true, this MPLS tunnel is facility-bypass (FB) tunnel",
          "default": false
        },
        "softPreemption": {
          "type": "string",
          "description": "If true, soft preemption is enabled. Applicable to dynamic TE unidirectional tunnels only.",
          "enum": ["enable", "disable"]
        },
        "stickyLsp": {
          "type": "string",
          "description": "A flag indicating a dynamic tunnel stays on the same path after change in required resources. Applicable to dynamic coRouted tunnels only.",
          "enum": ["on", "off"]
        },
        "mbbHistory": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MbbHistoryEntry"
          }
        },
        "frr": {
          "description": "MPLS FRR details attributes",
          "$ref": "#/definitions/MplsFrr"
        },
        "fb": {
          "description": "MPLS FB tunnel attributes",
          "$ref": "#/definitions/MplsFb"
        },
        "shareSrlg": {
          "type": "array",
          "description": "A list of share SRLG values used by dynamic tunnel during provisioning.",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "MsgsLastError": {
      "type": "object",
      "properties": {
        "errorCode": {
          "type": "string",
          "description": "Error code for last error"
        },
        "errorSubCode": {
          "type": "string",
          "description": "Sub error code for last error"
        }
      }
    },
    "NameToCapacityMappingRules": {
      "type": "object",
      "properties": {
        "namingUnit": {
          "type": "string",
          "description": "Unit of namespace."
        },
        "capacityUnit": {
          "type": "string",
          "description": "Unit of the capacity."
        },
        "relationType": {
          "type": "string",
          "description": "Relation type",
          "enum": ["ONE_TO_ONE", "ONE_TO_MANY"]
        },
        "mapping": {
          "type": "string",
          "description": "Identifies namespace to capacity mapping.",
          "enum": ["FIXED", "FLEXIBLE", "FLEXIBLE_GROUPED", "ALL"]
        },
        "noOfUnits": {
          "type": "integer",
          "format": "int32",
          "description": "Number 1-80 in switching and broadband case"
        },
        "mapperRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MapperRule"
          }
        }
      }
    },
    "NameValuePair": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "NamingRules": {
      "type": "object",
      "properties": {
        "total": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "used": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        },
        "potentialGrowth": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Capacity"
          }
        }
      }
    },
    "NetworkElement": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name/tid of the Network Element (e.g. OTTAWA_001)."
        },
        "siteName": {
          "type": "string",
          "description": "The site name of the NE. May be a CLLI or some other customer defined format."
        },
        "planningId": {
          "type": "string",
          "description": "The opaque id provided by a planning tool interacting with IFD."
        }
      }
    },
    "Note": {
      "type": "object",
      "properties": {
        "noteMsg": {
          "type": "string",
          "description": "The message left on the note left by the user"
        },
        "lastUpdatedBy": {
          "type": "string",
          "description": "The name of the user that last edited the note"
        },
        "lastUpdatedTime": {
          "type": "string",
          "description": "The time the note was last updated"
        }
      }
    },
    "PhotonicSpectrumPackage": {
      "type": "object",
      "properties": {
        "minFreqDeadBand": {
          "type": "string",
          "description": "Lower dead band in GHz. The dead band will be in format of 'xxxx.xxx'."
        },
        "maxFreqDeadBand": {
          "type": "string",
          "description": "Upper dead band in GHz. The dead band will be in format of 'xxxx.xxx'."
        },
        "targetMinFreq": {
          "type": "string",
          "description": "Allows the automatic adjustment of the MINFREQ when any associated NMCTP are deleted. Default is MINFREQ (no target lower frequency)."
        },
        "targetMaxFreq": {
          "type": "string",
          "description": "Allows the automatic adjustment of the MAXFREQ when any associated NMCTP are deleted. Default is MAXFREQ (no target upper frequency)."
        },
        "minFreqGuardBand": {
          "type": "string",
          "description": "Indicates the minimum required frequency spacing for the previous NMC."
        },
        "maxFreqGuardBand": {
          "type": "string",
          "description": "Indicates the minimum required frequency spacing for the next NMC."
        },
        "freqResolution": {
          "type": "string",
          "description": "Indicates the recurring frequency step that is allowed to be configured on the transponder."
        },
        "signalBandWidth10DB": {
          "type": "string",
          "description": "Captures Tx Signal Bandwidth in GHz measured at 10 dBm less than peak power."
        },
        "signalBandWidth3DB": {
          "type": "string",
          "description": "Captures Tx Signal Bandwidth in GHz measured at 3 dBm less than peak power."
        },
        "frequency": {
          "type": "string",
          "description": "The central signal frequency."
        },
        "minFreq": {
          "type": "string",
          "description": "The minimum signal frequency."
        },
        "maxFreq": {
          "type": "string",
          "description": "The maximum signal frequency."
        },
        "wavelength": {
          "type": "string",
          "description": "The central signal wavelength."
        },
        "wavelengthGrid ": {
          "type": "string",
          "description": "A hexadecimal number representing the vector of wavelengths that can be used by this SNC. Each bit set within the number indicates which wavelength is currently configured"
        }
      }
    },
    "PowerPackage": {
      "type": "object",
      "properties": {
        "txActualPower": {
          "type": "string",
          "description": "Current transmitter power (dBm)."
        },
        "txMaxPower": {
          "type": "string",
          "description": "Maximum transmitter power level (dBm)."
        },
        "txMinPower": {
          "type": "string",
          "description": "Minimum transmitter power level (dBm)."
        },
        "rxActualPower": {
          "type": "string",
          "description": "Current receiver power (dBm)."
        },
        "rxMaxPower": {
          "type": "string",
          "description": "Maximum receiver power level (dBm)."
        },
        "rxMinPower": {
          "type": "string",
          "description": "Minimum receiver power level (dBm)."
        }
      }
    },
    "ProtocolVersion": {
      "type": "object",
      "properties": {
        "protocol": {
          "type": "string"
        },
        "major": {
          "type": "integer",
          "format": "int32"
        },
        "minor": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "RegenIdPackage": {
      "type": "object",
      "properties": {
        "regenTid": {
          "type": "string",
          "description": "This field is the Regen ID Tid"
        },
        "nearTransponder": {
          "type": "string",
          "description": "This field is near Transponder Shelf SLot Port."
        },
        "clientTransponder": {
          "type": "string",
          "description": "The Client Transponder Shelf SLot Port"
        },
        "mateInfo": {
          "type": "string",
          "description": "This field is Mate Info String."
        }
      }
    },
    "ResiliencyTopologyPackage": {
      "type": "object",
      "properties": {
        "switchTpeId": {
          "type": "string",
          "description": "Switch port client TPE"
        },
        "resilientFreId": {
          "type": "string",
          "description": "Resilient nodal fre id"
        }
      }
    },
    "RouteConstraints": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "The route type i.e. photonic. In the future, other types may be supported.",
          "enum": ["photonic"]
        },
        "numberOfRoutes": {
          "type": "string",
          "description": "Number of routes defined by the configuration. For example, a PRIME/MEMBER configuration.  Could be a number, or could be a number evident from the model i.e. inverseMux. Generally, should only be specified if the configuration implies more than 1 route."
        },
        "sizeOfEachRoute": {
          "type": "string",
          "description": "For each route, what is the required size of each route. For example, '200G' in the case of 400G WLAi OTR 2xOTSi."
        },
        "maxInCpGroup": {
          "type": "string",
          "description": "Maximum number of routes that can be present in a control plane group. Could be a number, or could be a number evident n the model i.e. inverseMux."
        },
        "routeCharacteristic": {
          "type": "string",
          "description": "If multiple routes need to be defined, what's the relationship between the routes.",
          "enum": ["coRouted", "maximumDiversity"]
        },
        "signalPattern": {
          "type": "string",
          "description": "If photonic route type, specifies the frequency or wavelength pattern to choose for the routes.",
          "enum": ["adjacent"]
        }
      }
    },
    "RouteObject": {
      "type": "object",
      "properties": {
        "routeObjectType": {
          "type": "string",
          "description": "The attribute defining the route type.",
          "enum": [
            "TERMINATION_POINT_NAME",
            "ROADM_LINE_NAME",
            "NODE_NAME",
            "SITE_NAME",
            "CONTROL_PLANE",
            "FREQUENCY",
            "SNCG",
            "SNC",
            "SNCG_STATE"
          ]
        },
        "terminationPointName": {
          "description": "Specifies the location of an endpoint.",
          "$ref": "#/definitions/TerminationPointName"
        },
        "roadmLineName": {
          "type": "string",
          "description": "The ROADM Line Name. The routeObjectType attribute must be set to ROADM_LINE_NAME."
        },
        "nodeName": {
          "type": "string",
          "description": "The Node/ROADM/Network Construct Name. The routeObjectType attribute must be set to NODE_NAME."
        },
        "siteName": {
          "type": "string",
          "description": "The Site Name. The routeObjectType attribute must be set to SITE_NAME."
        },
        "controlPlane": {
          "type": "string",
          "description": "Technology layer of the control plane.",
          "enum": ["L_0"]
        },
        "frequency": {
          "type": "string",
          "description": "L0 frequency. The routeObjectType attribute must be set to FREQUENCY."
        },
        "sncg": {
          "type": "string",
          "description": "SNCG id. The routeObjectType attribute must be set to SNCG."
        },
        "snc": {
          "type": "string",
          "description": "SNC id. The routeObjectType attribute must be set to SNC."
        },
        "sncgState": {
          "type": "string",
          "description": "Attribute defining the SNCG State.",
          "enum": ["IS", "OOS"]
        }
      }
    },
    "ServiceAlias": {
      "type": "object",
      "properties": {
        "aliasType": {
          "type": "string",
          "description": "<br/>CLFI - Common Language Facility code<br/>DISTINGUISHED_NAME - Distinguished Alias Name<br/>MANAGEMENT_NAME - the CESD VS name",
          "enum": ["CLFI", "DISTINGUISHED_NAME", "MANAGEMENT_NAME"]
        },
        "name": {
          "type": "string",
          "description": "The free string name value associated with selected aliasType."
        }
      }
    },
    "ServiceIntentEndPoint": {
      "type": "object",
      "properties": {
        "networkElement": {
          "description": "Data associated with a particular network element.",
          "$ref": "#/definitions/NetworkElement"
        },
        "shelf": {
          "type": "string",
          "description": "Optional node shelf location identifier."
        },
        "slot": {
          "type": "string",
          "description": "Optional node slot location identifier."
        },
        "port": {
          "type": "string",
          "description": "The node port location identifier."
        },
        "subport": {
          "type": "string",
          "description": "The node subport location identifier"
        },
        "eqptGrp": {
          "type": "string",
          "description": "The node Equipment Group location identifier"
        },
        "lspName": {
          "type": "string",
          "description": "The name of the label switch path ids(unique) of the service to be created and activated"
        },
        "pseudoWireId": {
          "type": "string",
          "description": "The name of the pseudoWireId(unique) of the MPLS service to be created and activated"
        },
        "tunnelRole": {
          "type": "string",
          "description": "Role of the MPLS tunnel headEnd or tailEnd",
          "enum": ["headEnd", "tailEnd"]
        },
        "protectionRole": {
          "type": "string",
          "description": "Role of the MPLS protection primary or backup",
          "enum": ["primary", "backup"]
        },
        "layerTerminations": {
          "type": "array",
          "description": "Transmission parameters to be provisioned on TPE layer terminations.",
          "items": {
            "$ref": "#/definitions/LayerTermination"
          }
        },
        "interfaceType": {
          "type": "string",
          "description": "Convenient instruction to identify the endpoint role.",
          "enum": ["UNI"]
        }
      }
    },
    "ServiceIntentRequest": {
      "type": "object",
      "properties": {
        "data": {
          "description": "Resource to specify intent to design and fulfill one service.",
          "$ref": "#/definitions/ServiceIntentRequestData"
        }
      }
    },
    "ServiceIntentRequestAttributes": {
      "type": "object",
      "properties": {
        "turnUpDateTime": {
          "type": "string",
          "format": "date-time",
          "description": "The optional time when the service is to be activated. If omitted the service shall be activated immediately (now)."
        },
        "turnDownDateTime": {
          "type": "string",
          "format": "date-time",
          "description": "The optional time when the service is to be de-activated. If omitted the service shall remain activated until explicit deletion."
        },
        "aliasNames": {
          "type": "array",
          "description": "One or more alias names that identify the service to be created and activated.",
          "items": {
            "$ref": "#/definitions/ServiceAlias"
          }
        },
        "label": {
          "type": "string",
          "description": "The user label (not necessarily unique) of the service to be created and activated."
        },
        "directionality": {
          "type": "string",
          "description": "Indicates if the FRE is unidirectional or bidirectional.",
          "enum": ["bidirectional", "unidirectional"]
        },
        "layerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "evcPortType": {
          "type": "string",
          "description": "Convenient instruction about handling endpoint data (e.g. ETHERNET differentiates EPL from EVPL via CVID).",
          "enum": ["MAPPED", "TRANSPARENT"]
        },
        "endPoints": {
          "type": "array",
          "description": "All the endpoints involved in the definition of the service. Two instances must always be defined based on supported service type.",
          "items": {
            "$ref": "#/definitions/ServiceIntentEndPoint"
          }
        },
        "constraints": {
          "description": "Set of various constraints used to configure the service intent.",
          "$ref": "#/definitions/Constraints"
        },
        "postActivationTests": {
          "$ref": "#/definitions/Diagnostics"
        }
      }
    },
    "ServiceIntentRequestData": {
      "type": "object",
      "properties": {
        "attributes": {
          "description": "Attributes of the Service Intent Request. All supported services are PointToPoint at this time.",
          "$ref": "#/definitions/ServiceIntentRequestAttributes"
        }
      }
    },
    "ServiceIntentResponse": {
      "type": "object",
      "properties": {
        "data": {
          "description": "The Service Intent Response data resource.",
          "$ref": "#/definitions/ServiceIntentResponseData"
        }
      }
    },
    "ServiceIntentResponseArray": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "description": "Array containing all Service Intent Response Data obtained from the request.",
          "items": {
            "$ref": "#/definitions/ServiceIntentResponseData"
          }
        }
      }
    },
    "ServiceIntentResponseAttributes": {
      "type": "object",
      "properties": {
        "creationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time at which the service intent was created."
        },
        "intentState": {
          "type": "string",
          "description": "The current state of the service intent."
        },
        "supportingServices": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "request": {
          "description": "Resource to specify intent to design and fulfill one service.",
          "$ref": "#/definitions/ServiceIntentRequestData"
        },
        "discovered": {
          "type": "boolean",
          "description": "True if the Service Intent was discovered/promoted from the network.",
          "default": false
        },
        "postActivationTestStatus": {
          "$ref": "#/definitions/DiagnosticStatuses"
        }
      }
    },
    "ServiceIntentResponseData": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "The unique identifier of the service intent."
        },
        "type": {
          "type": "string",
          "description": "The type of the service intent."
        },
        "attributes": {
          "description": "Attributes of the Service Intent Response.",
          "$ref": "#/definitions/ServiceIntentResponseAttributes"
        }
      }
    },
    "ServiceIntentRoute": {
      "type": "object",
      "properties": {
        "aToZRoute": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServiceIntentRouteLink"
          }
        },
        "zToARoute": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServiceIntentRouteLink"
          }
        },
        "supportingRoadmLines": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "sharedRiskLinkGroupNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "ServiceIntentRouteAttributes": {
      "type": "object",
      "properties": {
        "aToZRoute": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServiceIntentRouteLink"
          }
        },
        "zToARoute": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServiceIntentRouteLink"
          }
        },
        "supportingRoadmLines": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "sharedRiskLinkGroupNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "ServiceIntentRouteData": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Service Intent ID."
        },
        "type": {
          "type": "string",
          "description": "The object type: serviceIntentRoute."
        },
        "attributes": {
          "description": "Attributes of the Service Intent Route.",
          "$ref": "#/definitions/ServiceIntentRouteAttributes"
        }
      }
    },
    "ServiceIntentRouteLink": {
      "type": "object",
      "properties": {
        "aPoint": {
          "description": "Specifies the location of a link endpoint.",
          "$ref": "#/definitions/ServiceIntentRouteLinkEndPoint"
        },
        "zPoint": {
          "description": "Specifies the location of a link endpoint.",
          "$ref": "#/definitions/ServiceIntentRouteLinkEndPoint"
        },
        "directionality": {
          "type": "string",
          "description": "Describes the directionality of the routes traffic flow.",
          "enum": ["UNIDIRECTIONAL", "BIDIRECTIONAL"]
        },
        "layerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        }
      }
    },
    "ServiceIntentRouteLinkEndPoint": {
      "type": "object",
      "properties": {
        "networkElementName": {
          "type": "string",
          "description": "Identification of the node using its natural name from the NE NBI protocol (e.g. TID for TL1, sysName for SAOS)."
        },
        "shelf": {
          "type": "string",
          "description": "Optional shelf location identifier."
        },
        "slot": {
          "type": "string",
          "description": "Optional slot location identifier."
        },
        "port": {
          "type": "string",
          "description": "The port location identifier."
        },
        "wavelength": {
          "type": "string",
          "description": "The wavelength location identifier."
        }
      }
    },
    "ServiceIntentRoutes": {
      "type": "object",
      "properties": {
        "data": {
          "description": "The Service Intent Routes Data Resource.",
          "$ref": "#/definitions/ServiceIntentRoutesData"
        }
      }
    },
    "ServiceIntentRoutesAttributes": {
      "type": "object",
      "properties": {
        "routes": {
          "description": "Service Intent Route.",
          "$ref": "#/definitions/ServiceIntentRoute"
        }
      }
    },
    "ServiceIntentRoutesData": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Service Intent ID."
        },
        "type": {
          "type": "string",
          "description": "The object type: serviceIntentRoutes."
        },
        "attributes": {
          "description": "Resource containing information pertaining to the routes of the Service Intent.",
          "$ref": "#/definitions/ServiceIntentRoutesAttributes"
        }
      }
    },
    "SignalIndex": {
      "type": "object",
      "properties": {
        "wavelength": {
          "type": "string",
          "description": "The signal wavelength (nm)."
        },
        "wavelengthMin": {
          "type": "string",
          "description": "The minimum signal wavelength."
        },
        "wavelengthMax": {
          "type": "string",
          "description": "The maximum signal wavelength."
        },
        "index": {
          "type": "string",
          "description": "The signal index. Indicates a time slot."
        },
        "odu2_index": {
          "type": "string",
          "description": "The odu2 index. Indicates a time slot or tributary port number."
        },
        "odu3_index": {
          "type": "string",
          "description": "The odu3 index. Indicates a time slot or tributary port number."
        },
        "odu4_index": {
          "type": "string",
          "description": "The odu4 index. Indicates a time slot or tributary port number."
        },
        "oduCn_index": {
          "type": "string",
          "description": "The oduCn index. Indicates a time slot or tributary port number."
        },
        "eth_index": {
          "type": "string",
          "description": "The eth index."
        },
        "indexes": {
          "description": "Map of index attributes to represent more than one indexes per LT. Plan is to remove above odu2_index, odu4_index & oduCn_index signal attributes in future and use this one",
          "$ref": "#/definitions/Indexes"
        },
        "channels": {
          "type": "array",
          "description": "Indicates the list of discrete channels utilized e.g. tributary slots on broadband cards. Plans are to utilize this generically for any list of discrete list of signals.",
          "items": {
            "type": "string"
          }
        },
        "ots_index": {
          "type": "string",
          "description": "The ots index. Indicates a time slot."
        },
        "phy_index": {
          "type": "string",
          "description": "The physical index. Indicates a time slot."
        },
        "mappingTable": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MappingTableEntry"
          }
        },
        "frequency": {
          "type": "string",
          "description": "The central signal frequency."
        },
        "minFreq": {
          "type": "string",
          "description": "The minimum signal frequency."
        },
        "maxFreq": {
          "type": "string",
          "description": "The maximum signal frequency."
        },
        "width": {
          "type": "string",
          "description": "The signal width."
        },
        "mgmtMcId": {
          "type": "string",
          "description": "The management identifier of the media channel"
        }
      }
    },
    "StatusLine": {
      "type": "object",
      "properties": {
        "statusCode": {
          "type": "integer",
          "format": "int32"
        },
        "reasonPhrase": {
          "type": "string"
        },
        "protocolVersion": {
          "$ref": "#/definitions/ProtocolVersion"
        }
      }
    },
    "TandemConnectionMonitoring": {
      "type": "object",
      "properties": {
        "nativeName": {
          "type": "string",
          "description": "The name of the TCM TPE that is native to the network element."
        },
        "userLabel": {
          "type": "string",
          "description": "The label given to the TCM TPE by an user"
        },
        "owner": {
          "type": "string",
          "description": "Identifies who created the TCM facility"
        },
        "suppTpeNativeName": {
          "type": "string",
          "description": "The supporting Termination Point"
        },
        "mode": {
          "type": "string",
          "description": "Identifies the mode of the TCM"
        },
        "state": {
          "type": "string",
          "description": "Primary State of TCM CTP"
        },
        "additionalAttributes": {
          "description": "Various miscellaneous attributes that do not necessarily belong in the parent resource. Attributes are populated dynamically and therefore cannot be documented here.",
          "$ref": "#/definitions/AdditionalAttributes"
        }
      }
    },
    "Termination": {
      "type": "object",
      "properties": {
        "connectionRulesInOwnLayer": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ConnectionRule"
          }
        }
      }
    },
    "TerminationPointName": {
      "type": "object",
      "properties": {
        "deviceAlias": {
          "$ref": "#/definitions/DeviceAlias"
        },
        "location": {
          "description": "A location object describes the location an entity in the network (Equipment, FRE, TPE, etc.). The amount of address data required to precisely reflect the position of an entity in the network is dependent on the entity in question (i.e. TPEs typically require more information then equipment). Location is typically used in conjunction with a network element identifier to uniquely identify position within a network.",
          "$ref": "#/definitions/Location"
        }
      }
    },
    "TpeCfmPackage": {
      "type": "object",
      "properties": {
        "cfmServiceName": {
          "type": "string",
          "description": "The name of the CFM service"
        },
        "mep": {
          "type": "array",
          "description": "Each entry holds information about one Maintenance Endpoint configured on this TPE",
          "items": {
            "$ref": "#/definitions/MepEntry"
          }
        }
      }
    },
    "TrafficProfile": {
      "type": "object",
      "properties": {
        "inputParams": {
          "type": "array",
          "description": "List of input parameters to be matched to derive the correct trafficProfile for the use-case.",
          "items": {
            "$ref": "#/definitions/TrafficProfileParam"
          }
        },
        "trafficParams": {
          "type": "array",
          "description": "List of traffic parameters that must be used as input in the use-case.",
          "items": {
            "$ref": "#/definitions/TrafficProfileParam"
          }
        },
        "routeConstraints": {
          "description": "Defines the traffic profile route characteristics used to data-drive provisioning workflows.",
          "$ref": "#/definitions/RouteConstraints"
        },
        "outputs": {
          "type": "array",
          "description": "List of outputs that are expected in the use-case.",
          "items": {
            "$ref": "#/definitions/TrafficProfileParam"
          }
        }
      }
    },
    "TrafficProfileParam": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of attribute."
        },
        "value": {
          "type": "string",
          "description": "Value of attribute."
        },
        "selectFrom": {
          "type": "array",
          "description": "Alternate form of value attribute that permits a comma separated list of the choices available for selection.",
          "items": {
            "type": "string"
          }
        },
        "layerRate": {
          "type": "string",
          "description": "The transmission layer rate.",
          "enum": [
            "ETHERNET",
            "OTU1",
            "OTU2",
            "OTU2e",
            "OTU3",
            "OTU4",
            "OTUCn",
            "OTSi",
            "OMS",
            "OS",
            "PHY",
            "OTS",
            "FICON",
            "FC",
            "ODU",
            "ODU0",
            "ODU1",
            "ODU2",
            "ODU2e",
            "ODU3",
            "ODU4",
            "ODUCn",
            "DSR",
            "DSR_10GE",
            "DSR_100GE",
            "DSR_ETHERNET",
            "ENCAPSULATION",
            "MPLS",
            "MPLS_PROTECTION",
            "MEDIA",
            "LAG",
            "RS",
            "E0",
            "E1",
            "E3",
            "E1_2M",
            "EC1",
            "DSR_2M",
            "LINE_OC3_STS3_AND_MS_STM1",
            "SECTION_OC3_STS3_AND_RS_STM1",
            "DSR_OC3_STM1",
            "DSR_OC12_STM4",
            "DSR_OC48_STM16",
            "DSR_OC192_STM64",
            "CES_IWF",
            "T1",
            "DSR_1_5M",
            "STS1",
            "STS3C",
            "STS12C",
            "STS24C",
            "STS48C",
            "DS0",
            "DS1",
            "DS3",
            "VT15",
            "VT2",
            "NOT_APPLICABLE",
            "ODUFLEX",
            "OTUg",
            "ODUg",
            "BGP",
            "G8032",
            "VC3",
            "VC4",
            "VC4_4C",
            "VC4_8C",
            "VC4_16C",
            "VC4_64C",
            "VC11",
            "VC12",
            "IP",
            "ES"
          ]
        },
        "location": {
          "type": "string",
          "description": "If an input, where to find the attribute. If an output, where to set the attribute.",
          "enum": ["self", "intent", "farEnd", "immediateClientTpe"]
        }
      }
    },
    "TtiAttribute": {
      "type": "object",
      "properties": {
        "sapi": {
          "type": "string",
          "description": "String to hold 'sapi' attribute"
        },
        "dapi": {
          "type": "string",
          "description": "String to hold 'dapi' attribute"
        },
        "operator": {
          "type": "string",
          "description": "String to hold 'operator' attribute"
        }
      }
    },
    "TtiPackage": {
      "type": "object",
      "properties": {
        "ttiTx": {
          "description": "This package stores tti Attribute information.",
          "$ref": "#/definitions/TtiAttribute"
        },
        "ttiRx": {
          "description": "This package stores tti Attribute information.",
          "$ref": "#/definitions/TtiAttribute"
        },
        "ttiExpectedRx": {
          "description": "This package stores tti Attribute information.",
          "$ref": "#/definitions/TtiAttribute"
        },
        "traceFailedMode": {
          "type": "string",
          "enum": ["NULL", "ALARM", "ALARM_FAIL_LINE"]
        }
      }
    },
    "TunnelPath": {
      "type": "object",
      "properties": {
        "pathName": {
          "type": "string",
          "description": "The name of this explicit tunnel path"
        },
        "hops": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HopEntry"
          }
        }
      }
    },
    "TxInfo": {
      "type": "object",
      "properties": {
        "dropPort": {
          "type": "string",
          "description": "dropPort Info"
        },
        "transMode": {
          "type": "string",
          "description": "transMode Info"
        },
        "frequency": {
          "type": "string",
          "description": "frequency Info"
        },
        "minDispersion": {
          "type": "string",
          "description": "minDispersion Info"
        },
        "maxDispersion": {
          "type": "string",
          "description": "maxDispersion Info"
        },
        "lowFrequencyGuardband": {
          "type": "string",
          "description": "lowFrequencyGuardband Info"
        },
        "highFrequencyGuardband": {
          "type": "string",
          "description": "highFrequencyGuardband Info"
        },
        "expectedRestorationTime": {
          "type": "string",
          "description": "expectedRestorationTime Info"
        },
        "linkOptimizationMode": {
          "type": "string",
          "description": "linkOptimizationMode Info"
        }
      }
    },
    "Y1731Attributes": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "True when the particular measurement is enabled",
          "default": false
        },
        "interval": {
          "type": "string",
          "description": "The interval between transmitting each message (e.g.: 1)"
        },
        "intervalUnit": {
          "type": "string",
          "description": "The unit of interval between transmitting each message (e.g.: seconds)"
        },
        "priority": {
          "type": "string",
          "description": "The priority of the messages being transmitted (0-7)"
        },
        "frameSize": {
          "type": "string",
          "description": "The frame size of the messages being transmitted (numeric), if applicable to this measurement"
        },
        "repeatDelay": {
          "type": "integer",
          "format": "int32",
          "description": "The repeat delay of the message being transmitted"
        },
        "count": {
          "type": "integer",
          "format": "int32",
          "description": "The count of the message being transmitted"
        },
        "iterate": {
          "type": "integer",
          "format": "int32",
          "description": "The iteration number of the message being transmitted"
        },
        "remoteMepId": {
          "type": "string",
          "description": "The ID of the remote MEP"
        },
        "remoteMepMacAddress": {
          "type": "string",
          "description": "The MAC address of the remote MEP"
        }
      }
    }
  }
}
